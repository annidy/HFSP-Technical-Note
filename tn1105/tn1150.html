<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0081)http://developer.apple.com/library/mac/technotes/tn/tn1150.html#ForkDataStructure -->
<html><!-- Template 03-24-01 --><!--Includes revisions to code listings--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
            <meta id="book-resource-type" name="book-resource-type" content="Technical Note">
            <meta id="book-title" name="book-title" content="HFS Plus Volume Format">
            <meta id="book-root" name="book-root" content="./">
            <meta id="book-assignments" name="book-assignments" content="{Type/Technical Note}, {Framework/Core Services Layer/CoreServices}, {Topic/Data Management/File Management}">
            <meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/DTS10002989">
            <meta id="description" name="description" content="TN1150: Describes the physical layout of an HFS Plus volume.">
            <meta id="resources-uri" name="resources-uri" content="../../Resources/551/">
            <meta id="Generator" name="Generator" content="Gutenberg Static 26981M">
            <meta id="Copyright" name="Copyright" content="Copyright 2011 Apple Inc. All Rights Reserved.">
<link rel="stylesheet" type="text/css" href="static.css">


<link rel="stylesheet" href="adcstyle.css" type="text/css">
<link rel="stylesheet" href="style.css" type="text/css">

<title>Technical Note TN1150: HFS Plus Volume Format</title>

    <meta name="keywords" content="Mac OS 8 HFS Plus Volume format header B-trees catalog journal">
    <meta name="Description" content="Technical Note TN1150: This Technical Note describes the
on-disk format for an HFS Plus volume. It does not describe
any programming interfaces for HFS Plus volumes. Topics include:
HFS Plus Basics, Volume Header (structure and types), B-Trees,
Catalog File, Extents Overflow File, Allocation File, Attributes
File, Startup File, Hard Links, Symbolic Links, Journal,
Unicode Subtleties, HFS Wrapper, and Volume Consistency Checks.">


<meta name="categories" content="Files and System Releases">


<meta name="week-posted" content="Dec 27, 1999 - Jan 7, 2000">

<link rel="stylesheet" href="adcstyle.css" type="text/css"><script language="JavaScript" type="text/javascript" src="adc.js"></script>
<style type="text/css">.vimiumHUD, .vimiumHUD * {line-height: 100%;font-size: 11px;font-weight: normal;}.vimiumHUD {position: fixed;bottom: 0px;color: black;height: 13px;width: auto;max-width: 400px;min-width: 150px;text-align: left;background-color: #ebebeb;padding: 3px 3px 2px 3px;border: 1px solid #b3b3b3;border-radius: 4px 4px 0 0;font-family: Lucida Grande, Arial, Sans;z-index: 99999998;text-shadow: 0px 1px 2px #FFF;line-height: 1.0;opacity: 0;}.vimiumHUD a, .vimiumHUD a:hover {background: transparent;color: blue;text-decoration: underline;}.vimiumHUD a.close-button {float:right;font-family:courier new;font-weight:bold;color:#9C9A9A;text-decoration:none;padding-left:10px;margin-top:-1px;font-size:14px;}.vimiumHUD a.close-button:hover {color:#333333;cursor:default;-webkit-user-select:none;}</style></head>


<body bgcolor="#FFFFFF" id="StaticPage">
<article id="contents"><!-- CONTENTS -->
<div id="technical"><a name="//apple_ref/doc/uid/DTS10002989" title="HFS Plus Volume Format"></a>
<a name="top"></a>
<!-- begin_header_information --><!-- end_header_information -->
<!-- bottom_of_header_marker_comment -->
<!-- top_of_titles_marker_comment --><center><table width="600" cellpadding="0" cellspacing="0" border="0">
<tbody><tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1150</div>
<div id="pageheadsub">HFS+ Volume Format</div>
</h1>
</td></tr></tbody></table></center><!-- bottom_of_titles_marker_comment -->

<center><table border="0" cellspacing="1" width="600"><tbody><tr><td>
   
<!-- begin_header_box -->
<table width="600" cellpadding="0" cellspacing="0" border="0">
     <tbody><tr>
<td width="300" valign="top" scope="row">
    <table border="0" width="300" cellpadding="0" cellspacing="0">
            <tbody><tr>            
<td width="300"> <img src="tnmenutop.gif" alt="" align="bottom" width="300" height="7"></td>
  </tr>
  <tr bgcolor="#e6e6e6">
   <td background="tnmenubody.gif" width="300">
 <span id="menutitle">
目录 
  <br>
  <br>
 </span>
   </td>
  </tr>
  <tr bgcolor="#e6e6e6">
   <td background="tnmenubody.gif" width="300">
 <!-- begin_toc -->
<p id="menutext"><a href="#HFSPlusBasics">HFS+ Basics</a><br><br>
         <a href="#CoreConcepts">Core Concepts</a><br><br>
         
         <a href="#VolumeHeader">Volume Header</a><br><br>
         
         <a href="#BTrees">B-Trees</a><br><br>
         
         <a href="#CatalogFile">Catalog File</a><br><br>
         
         <a href="#ExtentsOverflowFile">Extents Overflow File</a><br><br>
         
         <a href="#AllocationFile">Allocation File</a><br><br>
         
         <a href="#AttributesFile">Attributes File</a><br><br>
         
         <a href="#StartupFile">Startup File</a><br><br>

         <a href="#HardLinks">Hard Links</a><br><br>
         
         <a href="#Symlinks">Symbolic Links</a><br><br>
         
         <a href="#Journal">Journal</a><br><br>

         <a href="#HFSX">HFSX</a><br><br>
         
         <a href="#MetadataZone">Metadata Zone</a><br><br>
         
         <a href="#HotFile">Hot Files</a><br><br>
	
         <a href="#UnicodeSubtleties">Unicode Subtleties</a><br><br>
         
         <a href="#HFSWrapper">HFS Wrapper</a><br><br>
         
         <a href="#VolumeConsistencyChecks">Volume Consistency Checks</a><br><br>
         
         <a href="#Summary">Summary</a><br><br>
         
         <a href="#Downloads">Downloadables</a></p>
                <!-- end_toc -->
</td>
  </tr>

  <tr>
   <td width="300" scope="row">
 <img src="tnmenubottom.gif" alt="" width="300" height="16">
   </td>
  </tr>
    </tbody></table>
</td>
  <td width="300" valign="top">
            
<!-- begin_intro_text -->
<p id="introtext">本技术文档用于描述HFS+分区。它并<b>没有</b>描述任何HFS+编程接口。</p>
         
        <p id="introtext">此文档面向在文件系统抽象层以下，直接操作HFS+的底层开发人员。
         包括数据恢复或移植HFS+到其它平台的开发人员。</p>
         
         <p id="introtext">此文档假设你已经具备HFS分区的基本知识，相关内容在
         <a href="http://developer.apple.com/techpubs/mac/Files/Files-99.html#HEADING99-0">Inside
         Macintosh: Files</a>.</p>
         
          <!-- end_intro_text -->
<!-- begin_date --><h4 align="center">[Mar 05, 2004]</h4><!-- end_date -->
         <p/>
         <h4 align="left">译者：<a href="http://blog.csdn.net/ani_di">annidy</a> 2013年3月8日</h4>
</td>
 </tr>
    </tbody></table>
 <!-- end_header_box -->
<br><br>
<hr width="500" align="center">
<br><br>      
<!-- begin_content -->      
         <h2><a name="HFSPlusBasics"></a>HFS+基础</h2>
         
         <p>HFS+是Mac OS的一种分区格式。HFS+第一次出现在 <a href="http://developer.apple.com/technotes/tn/tn1121.html#HFS%20Plus">Mac
         OS 8.1</a>。 HFS+的结构类似于HFS, 有少量的改变。下表总结了主要的不同点。</p>
         
         <p align="CENTER"><b>表 1</b> HFS 与 HFS+ 比较 </p><center>
           <table border="1">
            <tbody><tr>
               <td>
                  <p><b>特性</b></p>
               </td><td>
                  <p><b>HFS</b></p>
               </td><td>
                  <p><b>HFS+</b></p>
               </td><td>
                  <p><b>优势/注释</b></p>
               </td></tr>
            <tr>
               <td>
                  <p>显示名称</p>
               </td><td>
                  <p>Mac OS Standard</p>
               </td><td>
                  <p>Mac OS Extended</p>
               </td><td>
                  <p></p>
               </td></tr>
            <tr>
               <td>
                  <p>记录分配blocks的长度</p>
               </td><td>
                  <p>16 bits</p>
               </td><td>
                  <p>32 bits </p>
               </td><td>
                  <p>减少了大分区中可用空间，增加分区上的最大文件数。</p>
               </td></tr>
            <tr>
               <td>
                  <p>文件名长度</p>
               </td><td>
                  <p>31 字节</p>
               </td><td>
                  <p>255 字节</p>
               </td><td>
                  <p>提高跨平台交互性，有利于用户使用。</p>
               </td></tr>
            <tr>
               <td>
                  <p>文件名编码</p>
               </td><td>
                  <p>MacRoman</p>
               </td><td>
                  <p>Unicode</p>
               </td><td>
                  <p>国际化支持更好</p>
               </td></tr>
            <tr>
               <td>
                  <p>文件/目录的属性</p>
               </td><td>
                  <p>支持固定长度的属性 (FileInfo and
                  ExtendedFileInfo)</p>
               </td><td>
                  <p>支持未来 meta-data 扩展</p>
               </td><td>
                  <p>未来可能会使用一些属性增加Finder的体验</p>
               </td></tr>
            <tr>
               <td>
                  <p>OS启动支持</p>
               </td><td>
                  <p>系统目录 ID</p>
               </td><td>
                  <p>新增支持专用启动文件</p>
               </td><td>
                  <p>可用于非Mac OS系统从HFS+启动</p>
               </td></tr>
            <tr>
               <td>
                  <p>catalog node 大小</p>
               </td><td>
                  <p>512 bytes</p>
               </td><td>
                  <p>4 KB</p>
               </td><td>
                  <p>修改以适应其它变化。 (更长的文件名，更大的 catalog records (由于fields增多或变大)).</p>
               </td></tr>
            <tr>
               <td>
                  <p>最大文件大小</p>
               </td><td>
                  <p>2<sup>31</sup> bytes</p>
               </td><td>
                  <p>2<sup>63</sup> bytes</p>
               </td><td>
                  <p>有利于多媒体文件存放</p></td>
                  </tr></tbody></table></center>
         
         <p>新增的功能并不影响编程和系统调用。Mac OS 小于 9.0 的版本没有提供有关HFS+特殊功能的接口。</p>
         
         <p>总体来说，设计HFS+文件系统的目的是：</p>
         
         <ul>
            <li>有效地使用磁盘空间</li>
            <li>国际化的文件名</li>          
            <li>支持未来的一些特性</li>
            <li>可用于非Mac OS系统从HFS+启动</li>
         </ul>
         
         <p>下面的章节将会探讨HFS+是如何实现上述目标的。</p>
         
         <h3>高效的使用磁盘空间</h3>
         
         <p>HFS将磁盘分为大小相等的allocation blocks。用16位的来标识每个
         allocation blocks。所以最多有2<sup>16</sup> (65,536)个allocation blocks
         在一个卷上。每个allocation block通常是512的倍数并且总数小于
         65,536 (例如，用卷大小除65,535, 再向上取整到512的倍数)。
         每个非空的fork必须占用整数个allocation blocks。当分区很大时，
         浪费的空间将递增。</p>
         
         <p>HFS+使用32位来标识allocation
         blocks。总共有2 <sup>32</sup> (4,294,967,296)
         allocation blocks。更多的allocation blocks意味着每个block更小，
         特别是当卷超过1G时，平均浪费的空间会减少许多（allocation block的
         余数是不被使用的）。同时意味着更多的文件，因为剩余空间可以很好的分配到
         大量文件中。特别是如果有很多小文件。
         </p>
         
         <h3>文件名国际化支持更好</h3>
         
         <p>HFS使用31字节的字符串储存文件名。并没有任何信息用于指示其字符集。
         文件名的比较和排序默认使用Roman字符集。对使用其它国家（比如日本）很不友好。
         更糟的是，即使是Roman字符集，此算法仍然有问题。Finder和其它程序则根据当前系统来选择字符集。
         </p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>
                  
                  使用非Roman字符集问题是，HFS的文件名比较通常是大小写不敏感的。
                  这个算法在非Roman会奇怪的失败，导致HFS认为它们名字相同，尽管事实上不相同。</p>
</td></tr></tbody></table></center>
         
         <p>HFS+ 使用255个Unicode字符储存文件名。长文件名对于计算机
            生成的文件名非常适用（比如Java的类名）</p>
         
         <p>HFS的catalog的B树中，每个节点是512字节。HFS+一个文件名就可能达到512字节（包括文件名长度）。
            由于B树的索引节点至少有2个key（加上指针和节点描述），所以HFS+的catalog的节点大小更大，
            通常是4k。</p>
         
         <p>HFS的catalog的B树中，索引节点的key占用固定大小，即最大的key大小。
         在HFS+，key的大小是可变的。这样浪费的空间就少了，同等地有更多分支在树中（
         找到一个记录访问的节点更少）</p>
         
         <h3>未来支持Named Forks</h3>
         
         <p>在HFS卷上的文件有2种forks: data fork 和 resource fork，
         两者都可能是空。文件和目录还包含一些额外信息（catalog信息或元信息metadata），
         比如修改日期或 Finder 信息。</p>
         
         <p>苹果软件团队或第三方开发人员常常需要针对特殊文件存储特别的信息。
            某些情况（比如文件自定义图标），data或resource fork适用。
            但另外（比如自定义目录图标，文件共享访问权限），使用data或resource fork就满足不了了。</p>
         
         <p>很多产品都有一些特殊方案以解决与特定文件或目录相关数据A保存。
         由于它们并不由文件系统管理，所以可能与文件和目录结构不一致。</p>
         
         <p>HFS+有一个attribute文件，有单独的B树用于储存目录和文件。由于它是卷的一部分，
            所以即使文件或目录移动或重命名后依然有效，删除后相关信息也被删除。
            attribut文件的 records没有完全定义，但它的目的为任何文件和目录，提供任意数量的、以Unicode名字为key的forks。
         </p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>
                  
                  由于attributes文件还未完全定义，目前还不能在删除文件或目录时删除named fork。
                  将来删除named forks可能会检查是否有孤立named forks，并在下次mounted时一并删除。卷头的<code>lastMountedVersion</code> 字段可以用来检查是否需要该操作。
                  </p>
                  
                  <p>无论如何，程序应该删除其named forks，而非让它孤立。</p>
</td></tr></tbody></table></center>
         
         <h3>轻松设置启动分区</h3>
         
         <p>HFS+定义了一个单独的 <strong>startup file</strong>，
            它的非结构fork使得在启动时非常方便地就可以访问。
            <a href="#VolumeHeader">volume header</a> 中定义了文件的位置和大小。
            由于一些系统的ROM并不支持HFS或HFS+系统。在许多方面，启动文件可以看做是HFS的引导分区，
            而且更大，更容易调整（译注：例如NTFS的启动扇区）。
         </p>
         
<p><a href="#top">返回顶部</a></p>


         <h2><a name="CoreConcepts"></a>核心内容</h2>
         
         <p>HFS+使用一些互相关联的结构来组织卷上的数据。这些结构包括：</p>
         
         <ul>
            <li><a href="#VolumeHeader">volume header</a></li>
            
            <li><a href="#CatalogFile">catalog file</a></li>
            
            <li><a href="#ExtentsOverflowFile">extents overflow
            file</a></li>
            
            <li><a href="#AttributesFile">attributes file</a></li>
            
            <li><a href="#AllocationFile">allocation file</a>
            (bitmap)</li>
            
            <li><a href="#StartupFile">startup file</a></li>
         </ul>
         
         <p>每个结构都有自己的存放区域。本节的目的就是介绍分区结构，各个重要结构之间的联系，和HFS+用到的一些重要数据类型。</p>
         
         <h3>术语</h3>
         
         <p>HFS+ 规定了一个 <b>卷</b> 是如何存入于磁盘上。磁盘上最小存储单位是 <b>扇区</b>。它是每次读写磁盘的最小单位。对于硬盘来说，扇区的大小通常是512或2048。</p>
         
         <p>大部分HFS+中的数据结构都不依赖于扇区大小, 除了
         <a href="#Journal">journal</a>。因为journal需要根据扇区编号定位，扇区大小储存在<a href="#JournalHeader">journal header</a>的<code>jhdr_size</code> 域中（如果卷存在journal).</p>
         
         <p>HFS+ 分配的最小单位是 <b>allocation
         blocks</b>；它的大小是2的幂次，最小512。在分区格式化时就决定了，并且在使用中很难改变。每个location
         blocks 由 32-bit 的<b>allocation block
         number</b>来区分，所以最多可以有 2<sup>32</sup> 个
         allocation blocks 在一个卷上。目前allocation blocks被优化设置为4K。</p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  为了提高性能，allocation block的大小最好是扇区的整数倍。
                  如果卷里面包含了 <a href="#HFSWrapper">HFS wrapper</a>，
                  则wrapper的allocation block的大小和位置也应该是扇区的整数倍。
                  </p>
</td></tr></tbody></table></center>

         <p>所有卷里的结构，包括卷头都是一个或多个allocation blocks的一部分 (可变卷头除外，
         <a href="#OddSizeVolumes">见下</a>). 这一点与HFS不同，它有很多结构(boot blocks, master
         directory block, and bitmap) 不属于任何一个allocation block.</p>
         
         <p><a name="Clump"></a>为了让文件尽可能地相邻，避免出现碎片，
            磁盘通常将文件分为几个allocation block组or <b>clumps</b>。
            clump的大小问题allocation block的整数倍。默认组大小在volume header指定。</p>
         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  真实的文件分配算法在本文档中没有叙述。
                  算法的实现也没有要求一定要使用clump。
                  基本上它只是让volume header提供一个空间而已。
                  </p>
           </td></tr></tbody></table></center>
                  
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  Mac OS目前针对非临近的文件分配是直接它找到的下一个空闲block。
                  并连续分配最大的clump整数倍空间。起辅助防止碎片的作用。
                  </p>
                  </td></tr></tbody></table></center>
         
         <p>每个HFS+ 卷都是有一个 <b>volume header</b>.
         volume header 包含信息很杂，包括此卷的创建时间，文件数量，重要结构的位置等。
         volume header 总是在位于距卷开始1024字节处。</p>
         
         <p><b>alternate volume header</b> 是volume header的一个备份，在距卷尾1024字节处。卷头的1024字节
         (volume header之前)，和最后512字节 (alternate volume header之后)是<a href="#ReservedAndPadFields">保留区间</a>.
         所有包含了volume header, alternate volume header, 和上面保留区间所占用的区域都在 <a href="#AllocationFile">allocation file</a>
         中标记为占用。</p>
         
         <p>HFS+的卷包含5个 <b>特殊文件</b>，
         它们包含一些重要的结构以支持访问：目录，<b>用户文件</b>，和属性。
         这几个特殊文件是 catalog file, extents overflow file, allocation file, attributes
         file 和 startup file。特殊文件只有1个 data fork 并保存在 volume header 里。</p>
         
         <p><b>catalog file</b> 描述了目录和文件之间的结构。catalog file 包含文件和目录的
         <b>catalog information</b>，并以B-tree方式存储以方便搜索。</p>
         
         <p>catalog file 存储了文件和目录的名字，大小为255 Unicode 字符，细节
         <a href="#HFSPlusNames">如下</a>.</p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
The <a href="#BTrees">B-Trees</a> section contains
an in-depth description of the B-trees used by HFS+.</p></td></tr></tbody></table></center>
         
         <p><b>attributes file</b> 则是存储了目录和文件的特殊信息。它同样
         也是以B-tree方式组织结构的。未来它也会把一些特殊信息存储在外部fork中。
         （它与catalog file 存储文件的 data 和 resource forks 类似）</p>
         
         <p>HFS+ 把许多 allocation blocks 组织为entent, 一个
         <b>extent</b> 就是一段连续的 allocation blocks，标记有：
         起始 allocation block number 和 allocation blocks 数量。
         许多entent组成为一个链表，这个链表就称为fork。
         对于用户文件，开始8个extent存储在catalog file里，其余的则存储在
         <b>extents overflow file</b>，它同样也是以B-tree方式组织的。</p>
         
         <p>extents overflow file 甚至也存储了它自己的extent。对于启动文件，无疑会
         加重启动代码的难度，所以启动文件是分开存放的。它没有额外的extent在extents overflow file.</p>
         
         <p><b>allocation file</b> 用于标记那些allocation block 是空闲的。
         这部分的作用类似于HFS的volume bitmap。</p>
         
         <p><b>startup file</b> is another special file which
         facilitates booting of non-Mac OS computers from HFS+
         volumes.</p>
         
         <p>最后，还有一个 <b>bad block file</b> 来防止使用坏道。只是它
         通常只是依附于 extents overflow file 中。参考
         <a href="#BadBlockFile">Bad Block File</a> 以获取更多细节。
         </p>
         
         <h3>主要结构</h3>
         
         <p>HFS+的卷大致由7部分组成：</p>
         
         <ol>
            <li>user file forks,</li>
            
            <li>the allocation file (bitmap),</li>
            
            <li>the catalog file,</li>
            
            <li>the extents overflow file,</li>
            
            <li>the attributes file,</li>
            
            <li>the startup file, and</li>
            
            <li>unused space.</li>
         </ol>
         
         <p>图1 描述了它们在卷中的情况</p>
         
         
<center><img src="tn1150_001.png" alt="Organization of an HFS Plus Volume" width="297" height="450" align="bottom">
<p><b>图 1</b>. HFS+ 卷的组织。</p>
</center>
         
         <p>volume header 在固定的位置。而几个特殊文件可能出现在
         volume header 和 alternate volume header 之间的任一
         block。 它们之间的顺序也没有任何规定。</p>
         
         <p>The information on HFS+ volumes (with the possible
         exception of the alternate volume header, as discussed
         <a href="#OddSizeVolumes">below</a>) is organized solely
         in allocation blocks. Allocation blocks are simply a means
         of grouping space on the media into convenient parcels.
         The size of an allocation block is a power of two,
         and at least 512. The allocation block size is a volume
         header parameter whose value is set when the volume is
         initialized; it cannot be changed easily without
         reinitializing the volume.</p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  allocation block的大小是经典的速度与空间的平衡。
                  增加每个block的大小能减少每个文件分配的个数，加速访问。
                  每次磁盘I/O更大，负载减小。减少block的大小可降低每个文件浪费的空间，
                  从而更充分地利用磁盘。
                  </p>
   </td></tr></tbody></table></center>
                  
                  <a name="SmallAllocationBlockWarning"></a>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>警告:</b><br>
                  尽管在HFS+上使用小于4K的block是合法的，但是DTS还是建议使用最小4K。
                  太小会降低在4KB为簇的系统上访问性能，比如Mac OS X Server。</p>
</td></tr></tbody></table></center>
         
         <h3>基本数据类型</h3>
         
         <p>本节描述了一些HFS+卷里的基础数据类型。所有数据结构都用C语言定义。
         如果编译器会自动对齐结构，请加上一些标记以禁止。</p>
         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  HFS+的格式主要从HFS发展而来。当定义新格式时，会去除原来未使用的域（主要是MFS遗留域），
                  并重新安排其空间，使得总大小不变，而且每个域都已对齐（使用PowerPC的对齐方式）。
                  </p>
         </td></tr></tbody></table></center>
         
         <h4><a name="ReservedAndPadFields"></a>保留和补齐空间</h4>
         
         <p>本说明中许多域都是保留的，它有特殊的意义，即：</p>
         
         <ul>
            <li>当创建一个结构有保留域时，应该把它设置为0。</li>
            
            <li>当读一个结构时，应当忽略保留域的内容。</li>
            
            <li>当改变一个结构时，不应该修改保留域中的内容。</li>
         </ul>
         
         <p>这种定义方式可以有效地向后兼容。</p>
         
         <p>补齐域和保留域类似。不同点在于，前者是故意设计预留，后者是实现需要。</p>
         
         <h4>整数类型</h4>
         
         <p>所有整数都由下面基础类型构成：<code>UInt8</code>, <code>SInt8</code>,
         <code>UInt16</code>, <code>SInt16</code>,
         <code>UInt32</code>, <code>SInt32</code>,
         <code>UInt64</code>, 和 <code>SInt64</code>。 
         它们表示是无符号或有符号的8-bit, 16-bit, 32-bit, 和 64-bit 数字。</p>
         
         <p>所有多字节整数都以大端对齐格式存储。 即储存的方式是从最高的有效位到最低的有效位，
         字节从0到<i>n</i>-1 (比如类型<code>UInt</code><i>n</i> 和 <code>SInt</code><i>n</i>),
         第0位是最底的有效位。</p>
         
         <h4><a name="HFSPlusNames"></a>HFS+ 名字</h4>
         
         <p>文件和目录的名字为固定255个16-bit的
         Unicode 字符。定义为<code>HFSUniStr255</code>.</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct HFSUniStr255 {
    UInt16  length;
    UniChar unicode[255];
};
typedef struct HFSUniStr255 HFSUniStr255;
typedef const  HFSUniStr255 *ConstHFSUniStr255Param;</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p><code>UniChar</code> 是 <code>UInt16</code> 长度，
         定义的字符集在 <i> The Unicode Standard, Version 2.0</i>
         [Unicode, Inc. ISBN 0-201-48345-9] 中</p>
         
         <p>HFS+的字符串是未经压缩并按实际顺序存储的。字符串比较区分大小写，
         但包含Unicode字符的不适用，忽略之。更多细节参见<a href="#UnicodeSubtleties">Unicode
         细微之处</a>。</p>
         
         <p>一种HFS+的变种，称为<a href="#HFSX">HFSX</a>，
         允许更为新式的大小写敏感比较。也是未经压缩并按实际顺序存储，但Unicode字符参与比较。
         </p>
         
         <h4><a name="TextEncodings"></a>文件编码</h4>
         
         <p>传统的Mac OS编程接口传入的文件名是Pascal strings(嵌在<code>FSSpec</code>中的<code>StringPtr</code>或<code>Str63</code>）。它里面的字符不是Unicode的；
         而是取决于系统当前的语言和默认的编码。相同的序列可表示不同的Unicode字符，
         许多Unicode字符也出现在多种Mac OS的编码中。
         </p>
         
         <p>HFS+包含2种特别设计的特性用于Pascal string和Unicode之间的转换。
            第一个特性是在文件或目录的catalog records的
         <code>textEncoding</code>字段。它给出了一些有用的提示。
         </p>
         
         <p><code>textEncoding</code>字段可能的定义见表 2。</p>
         
         <p align="CENTER"><b>表 2</b> 文本编码</p>
         
         <center><table border="1">
            <tbody><tr>
               <td width="140">
                  <p><b>编码名称</b></p>
               </td><td width="60">
                  <p><b>值</b></p>
               </td><td width="140">
                  <p><b>编码名称</b></p>
               </td><td width="60">
                  <p><b>值</b></p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacRoman</p>
               </td><td width="60">
                  <p>0</p>
               </td><td width="140">
                  <p>MacThai</p>
               </td><td width="60">
                  <p>21</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacJapanese</p>
               </td><td width="60">
                  <p>1</p>
               </td><td width="140">
                  <p>MacLaotian</p>
               </td><td width="60">
                  <p>22</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacChineseTrad</p>
               </td><td width="60">
                  <p>2</p>
               </td><td width="140">
                  <p>MacGeorgian</p>
               </td><td width="60">
                  <p>23</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacKorean</p>
               </td><td width="60">
                  <p>3</p>
               </td><td width="140">
                  <p>MacArmenian</p>
               </td><td width="60">
                  <p>24</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacArabic</p>
               </td><td width="60">
                  <p>4</p>
               </td><td width="140">
                  <p>MacChineseSimp</p>
               </td><td width="60">
                  <p>25</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacHebrew</p>
               </td><td width="60">
                  <p>5</p>
               </td><td width="140">
                  <p>MacTibetan</p>
               </td><td width="60">
                  <p>26</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacGreek</p>
               </td><td width="60">
                  <p>6</p>
               </td><td width="140">
                  <p>MacMongolian</p>
               </td><td width="60">
                  <p>27</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacCyrillic</p>
               </td><td width="60">
                  <p>7</p>
               </td><td width="140">
                  <p>MacEthiopic</p>
               </td><td width="60">
                  <p>28</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacDevanagari</p>
               </td><td width="60">
                  <p>9</p>
               </td><td width="140">
                  <p>MacCentralEurRoman</p>
               </td><td width="60">
                  <p>29</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacGurmukhi</p>
               </td><td width="60">
                  <p>10</p>
               </td><td width="140">
                  <p>MacVietnamese</p>
               </td><td width="60">
                  <p>30</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacGujarati</p>
               </td><td width="60">
                  <p>11</p>
               </td><td width="140">
                  <p>MacExtArabic</p>
               </td><td width="60">
                  <p>31</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacOriya</p>
               </td><td width="60">
                  <p>12</p>
               </td><td width="140">
                  <p>MacSymbol</p>
               </td><td width="60">
                  <p>33</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacBengali</p>
               </td><td width="60">
                  <p>13</p>
               </td><td width="140">
                  <p>MacDingbats</p>
               </td><td width="60">
                  <p>34</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacTamil</p>
               </td><td width="60">
                  <p>14</p>
               </td><td width="140">
                  <p>MacTurkish</p>
               </td><td width="60">
                  <p>35</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacTelugu</p>
               </td><td width="60">
                  <p>15</p>
               </td><td width="140">
                  <p>MacCroatian</p>
               </td><td width="60">
                  <p>36</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacKannada</p>
               </td><td width="60">
                  <p>16</p>
               </td><td width="140">
                  <p>MacIcelandic</p>
               </td><td width="60">
                  <p>37</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacMalayalam</p>
               </td><td width="60">
                  <p>17</p>
               </td><td width="140">
                  <p>MacRomanian</p>
               </td><td width="60">
                  <p>38</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacSinhalese</p>
               </td><td width="60">
                  <p>18</p>
               </td><td width="140">
                  <p>MacFarsi</p>
               </td><td width="60">
                  <p>140 (49)</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacBurmese</p>
               </td><td width="60">
                  <p>19</p>
               </td><td width="140">
                  <p>MacUkrainian</p>
               </td><td width="60">
                  <p>152 (48)</p>
               </td></tr>
            <tr>
               <td width="140">
                  <p>MacKhmer</p>
               </td><td width="60">
                  <p>20</p>
               </td><td width="140">
                  <p></p>
               </td><td width="60">
                  <p></p>
               </td></tr>
         </tbody></table></center>
         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  非Mac OS的实现可能会选择忽略<code>textEncoding</code>。
                  这种情况下，该字段应该当做<a href="#ReservedAndPadFields">保留</a>
                  字段。</p>
          </td></tr></tbody></table></center>
                  
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  Mac OS在下面情况使用 <code>textEncoding</code> 字段。
                  当创建或重命名时，Mac OS将可支持的Pascal string转换到 <code>HFSUniStr255</code>。并把原始的文本编码名存放在<code>textEncoding</code>字段。
                  当Mac OS需要创建该record的Pascal string时，就可以用到
                  <code>textEncoding</code>了。这一提示信息可以高度还原文本，以使兼容性得到提升。
                  </p>
         </td></tr></tbody></table></center>
         
         <p>另一种使用则是在volume header的<code>encodingsBitmap</code> 字段。
            每个在catalog中使用过的文本编码，其应的bit都需要在 <code>encodingsBitmap</code> 中设置。
         </p>
         
         <p>删除文件时，不必清理此字段的对应位。
            这表示，即使没有任何文件存在，此字段也可以不为空。
         </p>
         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  <code>encodingsBitmap</code> 主要用于统计本分区使用的编码。
                  它有64位可用，事实上MacFarsi和MacUkrainian不能直接保存，它们使用了别的位置。
                  </p>
            </td></tr></tbody></table></center>
                  
 <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  Mac OS使用 <code>encodingsBitmap</code> 来决定那些转换表需要在mount时加载。
                  由于转换表太大，会花费很多时间和内存。对于不需要的转换表最好不要加载。
                  </p>
                  </td></tr></tbody></table></center>
                  
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>警告:</b><br>
                  
                  非Mac OS的HFS+实现必须正确维护 <code>encodingsBitmap</code>
                  字段。要确保使用过的文本编码在 <code>textEncoding</code> 
                  有相关记录。否则Mac OS在读写时可能会出现异常。
                  </p>
         </td></tr></tbody></table></center>
         
         <h4><a name="HFSPlusDates"></a>HFS+ 时间</h4>
         
         <p>HFS+在几个地方储存了时间，volume header和catalog records。
         它们的类型是32-bit整型(<code>UInt32</code>)，取之自1904年1月1日以来的秒数（GMT）。
         而HFS直接是当地时间。</p>
         
         <p>HFS+最大能表示的时间是February 6, 2040 06:28:15 GMT。</p>
         
         <p>The date values do not account for leap seconds. They do
         include a leap day in every year that is evenly divisible by
         four. This is sufficient given that the range of
         representable dates does not contain 1900 or 2100, neither
         of which have leap days.</p>
         
         <p>The implementation is responsible for converting these
         times to the format expected by client software. For
         example, the Mac OS File Manager passes dates in local time;
         the Mac OS HFS+ implementation converts dates between
         local time and GMT as appropriate.</p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  The creation date stored in
                  the Volume Header is NOT stored in GMT; it is
                  stored in local time. The reason for this is that
                  many applications (including backup utilities) use
                  the volume's creation date as a relatively unique
                  identifier. If the date was stored in GMT, and
                  automatically converted to local time by an
                  implementation (like Mac OS), the value would
                  appear to change when the local time zone or
                  daylight savings time settings change (and thus
                  cause some applications to improperly identify the
                  volume). The use of the volume's creation date as a
                  unique identifier outweighs its use as a date. This
                  change was introduced late in the Mac OS 8.1
                  project.</p>
         </td></tr></tbody></table></center>
         
         <h4><a name="HFSPlusPermissions"></a>HFS+ 权限
         </h4>

         <p>每个文件和目录都有访问权限，定义为
         <code>HFSPlusBSDInfo</code> </p>
         
<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct HFSPlusBSDInfo {
    UInt32  ownerID;
    UInt32  groupID;
    UInt8   adminFlags;
    UInt8   ownerFlags;
    UInt16  fileMode;
    union {
        UInt32  iNodeNum;
        UInt32  linkCount;
        UInt32  rawDevice;
    } special;
};
typedef struct HFSPlusBSDInfo HFSPlusBSDInfo;</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>它们意义如下:</p>
         
         <dl>
            <dt><code>ownerID</code></dt>
            
            <dd>是文件或目录的拥有者用户的ID。
            Mac OS X 10.3以前，99号ID表示当前控制台登陆用户。如果没有用户登陆，则为root（ID 0）用户。
            Mac OS X 10.3认为ID 99的用户即是当前操作的用户(事实上,每个用户都同时拥有它)。这种替换只
            在运行时发生。磁盘上的user ID没有改变。</dd>
            
            <dt><code>groupID</code></dt>
            
            <dd>是文件或目录的拥有者用户组的ID。Mac OS X认为group ID为99属于"unknown"用户组。它并不会
            在运行时替换。</dd>
            
            <dt><code>adminFlags</code></dt>
            
            <dd>这个BSD标志只能由 super-user 设定。 only. This field
            corresponds to bits 16 through 23 of the <code>st_flags</code> field of <a href="http://developer.apple.com/documentation/Darwin/Reference/ManPages/html/stat.2.html">
            <code>struct stat</code></a> in Mac OS X. See the <a href="http://developer.apple.com/documentation/Darwin/Reference/ManPages/html/chflags.2.html">
            manual page for <code>chflags(2)</code></a> for more information. The following table
            gives the bit position in the <code>adminFlags</code> field and the name of the
            corresponding mask used in the <code>st_flags</code> field.
			<table>
				<colgroup><col width="35"> <col width="100"> <col width="200">
				</colgroup><tbody><tr><th style="text-align: left">Bit </th><th style="text-align: left"><code>st_flags</code> mask </th><th style="text-align: left">Meaning</th></tr>
				<tr><td scope="row">0	</td><td>SF_ARCHIVED		</td><td>File has been archived</td></tr>
				<tr><td scope="row">1	</td><td>SF_IMMUTABLE	</td><td>File may not be changed</td></tr>
				<tr><td scope="row">2	</td><td>SF_APPEND		</td><td>Writes to file may only append</td></tr>
			</tbody></table>
			</dd>

            <dt><code>ownerFlags</code></dt>
            
            <dd>这个BSD标志只能由拥有者或super-user设定。 This field corresponds to bits 0 through 7 of the
            <code>st_flags</code> field of <a href="http://developer.apple.com/documentation/Darwin/Reference/ManPages/html/stat.2.html">
            <code>struct stat</code></a> in Mac OS X. See the <a href="http://developer.apple.com/documentation/Darwin/Reference/ManPages/html/chflags.2.html">
            manual page for <code>chflags(2)</code></a> for more information. The following table
            gives the bit position in the <code>ownerFlags</code> field and the name of the
            corresponding mask used in the <code>st_flags</code> field.
            <table>
				<colgroup><col width="35"> <col width="100"> <col width="200">
				</colgroup><tbody><tr><th style="text-align: left">Bit </th><th style="text-align: left"><code>st_flags</code> mask </th><th style="text-align: left">Meaning</th></tr>
				<tr><td scope="row">0	</td><td>UF_NODUMP		</td><td>Do not dump (back up or archive) this file</td></tr>
				<tr><td scope="row">1	</td><td>UF_IMMUTABLE	</td><td>File may not be changed</td></tr>
				<tr><td scope="row">2	</td><td>UF_APPEND		</td><td>Writes to file may only append</td></tr>
				<tr><td scope="row">3	</td><td>UF_OPAQUE		</td><td>Directory is opaque (see <a href="#Union">below</a>)</td></tr>
			</tbody></table>
			</dd>
            
            <dt><code>fileMode</code></dt>
            
            <dd>BSD文件type和mode标志位. 注意，下面的定义都是八进制的。
<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>#define S_ISUID 0004000     /* set user id on execution */
#define S_ISGID 0002000     /* set group id on execution */
#define S_ISTXT 0001000     /* sticky bit */

#define S_IRWXU 0000700     /* RWX mask for owner */
#define S_IRUSR 0000400     /* R for owner */
#define S_IWUSR 0000200     /* W for owner */
#define S_IXUSR 0000100     /* X for owner */

#define S_IRWXG 0000070     /* RWX mask for group */
#define S_IRGRP 0000040     /* R for group */
#define S_IWGRP 0000020     /* W for group */
#define S_IXGRP 0000010     /* X for group */

#define S_IRWXO 0000007     /* RWX mask for other */
#define S_IROTH 0000004     /* R for other */
#define S_IWOTH 0000002     /* W for other */
#define S_IXOTH 0000001     /* X for other */

#define S_IFMT   0170000    /* type of file mask */
#define S_IFIFO  0010000    /* named pipe (fifo) */
#define S_IFCHR  0020000    /* character special */
#define S_IFDIR  0040000    /* directory */
#define S_IFBLK  0060000    /* block special */
#define S_IFREG  0100000    /* regular */
#define S_IFLNK  0120000    /* symbolic link */
#define S_IFSOCK 0140000    /* socket */
#define S_IFWHT  0160000    /* whiteout */
</pre></td>
</tr>
</tbody></table></center>
			在某些版本的Unix中, sticky 位, <code>S_ISTXT</code>, 是用于指示可执行文件是否在结束时仍然停留在内存中；
            用于加快下次启动的速度。Mac OS X 并没有使用些优化机制。
            如果用于目录，Mac OS X会限制对里面文件和目录的移动、删除和重命名，除非有写权限。
            </dd>
            
            <dt><code>special</code></dt>
            
            <dd>This field is used only for certain special kinds of files.
            For directories, and most files, this field is unused and
            <a href="#ReservedAndPadFields">保留</a>.  When used,
            this field is used as one of the following:</dd>
            
			<dt><code>iNodeNum</code></dt>
			
			<dd>For hard link files, this field contains the link reference number.
			See the <a href="#HardLinks">Hard Links</a> section for more
			information.</dd>
			
			<dt><code>linkCount</code></dt>
			
			<dd>For indirect node files, this field contains the number of hard links
			that point at this indirect node file. See the
			<a href="#HardLinks">Hard Links</a> section for more information.</dd>
			
			<dt><code>rawDevice</code></dt>
			
			<dd>For block and character special devices files (when the <code>S_IFMT</code>
			field contains <code>S_IFCHR</code> or <code>S_IFBLK</code>), this field
			contains the device number.</dd>
         </dl>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>警告:</b><br>                  
                  Mac OS 8 and 9 treat the permissions as
                  <a href="#ReservedAndPadFields">保留</a>.</p>
               
         </td></tr></tbody></table></center>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b><a name="Union"></a>提示:</b><br>
				The <code>S_IFWHT</code> and <code>UF_OPAQUE</code>
				values are used when the file system is mounted as part
				of a union mount.  A union mount presents the
				combination (union) of several file systems as a single
				file system.  Conceptually, these file systems are
				layered, one on top of another.  If a file or directory
				appears in multiple layers, the one in the top most
				layer is used.  All changes are made to the top most
				file system only; the others are read-only.  To delete a
				file or directory that appears in a layer other than the
				top layer, a whiteout entry (file type
				<code>S_IFWHT</code>) is created in the top layer.  If a
				directory that appears in a layer other than the top
				layer is deleted and later recreated, the contents in
				the lower layer must be hidden by setting the
				<code>UF_OPAQUE</code> flag in the directory in the top
				layer.  Both <code>S_IFWHT</code> and
				<code>UF_OPAQUE</code> hide corresponding names in lower
				layers by preventing a union mount from accessing the
				same file or directory name in a lower layer.
</p></td></tr></tbody></table></center>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>
				If the <code>S_IFMT</code> field (upper 4 bits) of the <code>fileMode</code>
				field is zero, then Mac OS X assumes that the permissions structure is
				uninitialized, and internally uses default values for all of the fields.
				The default user and group IDs are 99, but can be changed at the time the
				volume is mounted.  This default <code>ownerID</code> is then subject to
				substitution as described above.</p>
				
				<p>This means that files created by Mac OS 8 and 9, or any other implementation
				that sets the permissions fields to zeroes, will behave as if the
				"ignore ownership" option is enabled for those files, even if "ignore
				ownership" is disabled for the volume as a whole.</p>
</td></tr></tbody></table></center>

         <h4><a name="ForkDataStructure"></a>数据的Fork
         </h4>
         
         <p>HFS+用 <code>HFSPlusForkData</code> 结构来保存数据内容。一种是data fork, 另一种
         是 resource fork，它们都存储在每个文件的catelog record中。另外，volume header 也通过它储存那些特殊文件。</p>
         
         <p>未使用的HFSPlusExtentRecord中，<code>startBlock</code> 和
         <code>blockCount</code> 都设置为0. For example, if a given
         fork occupied three extents, then the last five extent
         descriptors would be all zeroes.</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct HFSPlusForkData {
    UInt64                  logicalSize;
    UInt32                  clumpSize;
    UInt32                  totalBlocks;
    HFSPlusExtentRecord     extents;
};
typedef struct HFSPlusForkData HFSPlusForkData;
&nbsp;
typedef HFSPlusExtentDescriptor HFSPlusExtentRecord[8];</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>结构中各个域的作用如下：</p>
         
         <dl>
            <dt><code>logicalSize</code></dt>
            
            <dd>该fork中数据的大小，单位字节。</dd>
            
            <dt><code>clumpSize</code></dt>
            
            <dd>For <code>HFSPlusForkData</code> structures in the
            <a href="#VolumeHeader">volume header</a>, this is the fork's
            <a href="#Clump">clump size</a>, which is used in preference to the
            default clump size in the <a href="#VolumeHeader">volume header</a>.<br><br>
            For <code>HFSPlusForkData</code> structures in a <a href="#CatalogFileRecord">
            catalog record</a>, this field was intended to store a per-fork
            <a href="#Clump">clump size</a> to override the default clump size
            in the <a href="#VolumeHeader">volume header</a>.  However, Apple
            implementations prior to Mac OS X version 10.3 ignored this field.
            As of Mac OS X version 10.3, this field is used to keep track of the
            number of blocks actually read from the fork.  See the <a href="#HotFile">Hot
            Files</a> section for more information.
            </dd>
            
            <dt><code>totalBlocks</code></dt>
            
            <dd>该fork中所有extents使用的allocation blocks数量。</dd>
            
            <dt><code>extents</code></dt>
            
            <dd>一个8个extent descriptors的数组。如果碎片太多以至不能满足，多余的extent储存在
            <a href="#ExtentsOverflowFile">extents overflow file</a>.</dd>
         
         </dl>
         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  The <code>HFSPlusExtentRecord</code> is also the
                  data record used in the
                  <a href="#ExtentsOverflowFile">extents overflow
                  file</a> (the extent record).</p>
         </td></tr></tbody></table></center>
         
         <p> <code>HFSPlusExtentDescriptor</code> 结构储存实际内容的信息。</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct HFSPlusExtentDescriptor {
    UInt32                  startBlock;
    UInt32                  blockCount;
};
typedef struct HFSPlusExtentDescriptor HFSPlusExtentDescriptor;</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>结构中各个域的作用如下：</p>
         
         <dl>
            <dt><code>startBlock</code></dt>
            
            <dd>第一个allocation block分配的位置</dd>
            
            <dt><code>blockCount</code></dt>
            
            <dd>allocation blocks的数量</dd>
         </dl>
      

<p><a href="#top">返回顶部</a></p>


         <h2><a name="VolumeHeader"></a>Volume Header</h2>
         
         <p>每个HFS+卷在1024字节处都有一个volume header。又称之为主目录块（
         header -- analogous to the master directory block (MDB)）。
         每次unmounted设备时都要更新些结构。</p>
         
         <p>一个volume header副本通常会存放于分区后1024字节。只有在调整分区大小或主要结构变化时才
         有可能更新此处。通常它用于磁盘修复程序。
         </p>
         
         <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  The first 1024 bytes are reserved for use as boot
                  blocks; the traditional Mac OS Finder will write to them when
                  the System Folder changes. The boot block format is
                  outside the scope of this specification. It is
                  defined in
                  <a href="http://developer.apple.com/techpubs/mac/Files/Files-101.html">Inside
                  Macintosh: Files</a>.</p>
                  
                  <p>The last 512 bytes were used during Apple's CPU
                  manufacturing process.</p>
         </td></tr></tbody></table></center>
         
         <p>allocation block (or blocks) 的前1563字节已设置为占用（1024+512）。
         具体参考
         <a href="#AllocationFile">Allocation File</a> 一节。</p>
         
       <a name="OddSizeVolumes"></a>
         
                  <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  备份volume header总是位于分区最后1024字节。如果分区大小不是
                  allocation block对齐的，这一部分可能超出了allocation block
                  的指示。</p>
         </td></tr></tbody></table></center>
         
         <p>The volume header 的结构是
         <code>HFSPlusVolumeHeader</code>。</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct HFSPlusVolumeHeader {
    UInt16              signature;
    UInt16              version;
    UInt32              attributes;
    UInt32              lastMountedVersion;
    UInt32              journalInfoBlock;
&nbsp;
    UInt32              createDate;
    UInt32              modifyDate;
    UInt32              backupDate;
    UInt32              checkedDate;
&nbsp;
    UInt32              fileCount;
    UInt32              folderCount;
&nbsp;
    UInt32              blockSize;
    UInt32              totalBlocks;
    UInt32              freeBlocks;
&nbsp;
    UInt32              nextAllocation;
    UInt32              rsrcClumpSize;
    UInt32              dataClumpSize;
    HFSCatalogNodeID    nextCatalogID;
&nbsp;
    UInt32              writeCount;
    UInt64              encodingsBitmap;
&nbsp;
    UInt32              finderInfo[8];
&nbsp;
    HFSPlusForkData     allocationFile;
    HFSPlusForkData     extentsFile;
    HFSPlusForkData     catalogFile;
    HFSPlusForkData     attributesFile;
    HFSPlusForkData     startupFile;
};
typedef struct HFSPlusVolumeHeader HFSPlusVolumeHeader;</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>结构中各个域的作用如下：</p>
         
         <dl>
            <dt><code>signature</code></dt>
            
            <dd>卷签名，必须是
            <code>kHFSPlusSigWord</code> (<code>'H+'</code>) 以表示是
            HFS+ 卷, 或 <code>kHFSXSigWord</code> (<code>'HX'</code>)
            表示是 <a href="#HFSX">HFSX</a> 卷.</dd>
            
            <dt><code>version</code></dt>
            
            <dd>卷格式的版本号, 当前HFS+版本号(<code>kHFSPlusVersion</code>)是
            4  , <a href="#HFSX">HFSX</a>版本号
            (<code>kHFSXVersion</code>) 是5.</dd>
            
            <dt><code>attributes</code></dt>
            
            <dd>Volume attributes, as
            <a href="#VolumeAttributes">described below</a>.</dd>
            
            <dt><code>lastMountedVersion</code></dt>
            
            <dd>A value which uniquely identifies the implementation
            that last mounted this volume for writing. This value can
            be used by future implementations to detect volumes that
            were last mounted by older implementations and check them
            for deficiencies.  Any code which modifies the on disk
            structures must also set this field to a unique value which
            identifies that code.  Third-party implementations of HFS+ should place a
            <a href="http://developer.apple.com/dev/cftype/register.html">registered creator
            code</a> in this field. The value used by Mac OS 8.1 to
            9.2.2 is <code>'8.10'</code>.
            The value used by Mac OS X is <code>'10.0'</code>.  The
            value used by a <a href="#Journal">journaled</a> volume
            (including <a href="#HFSX">HFSX</a>) in Mac OS X is <code>'HFSJ'</code>.
            The value used by fsck_hfs on Mac OS X is <code>'fsck'</code>.</dd>
         </dl>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  It is very important for implementations (and
                  utilities that directly modify the volume!) to set
                  the <code>lastMountedVersion</code>. It is also
                  important to choose different values when
                  non-trivial changes are made to an implementation
                  or utility. If a bug is found in an implementation
                  or utility, and it sets the
                  <code>lastMountedVersion</code> correctly, it will
                  be much easier for other implementations and
                  utilities to detect and correct any problems.</p>
         </td></tr></tbody></table></center>
         
         <dl>
            <dt><code>journalInfoBlock</code></dt>
            
            <dd>该卷日志的
            <a href="#JournalInfoBlock"><code>JournalInfoBlock</code></a>
            分配情况。日志只有在
            <code>kHFSVolumeJournaledBit</code> 标记设置后才有效。</dd>
			
            <dt><code>createDate</code></dt>
            
            <dd>创建时间，格式参考
            <a href="#HFSPlusDates">HFS+ Dates</a> 。</dd>
            
            <dt><code>modifyDate</code></dt>
            
            <dd>修改时间，，格式参考
            <a href="#HFSPlusDates">HFS+ Dates</a> 。</dd>
            
            <dt><code>backupDate</code></dt>
            
            <dd>备份时间；通常由应用程序使用。格式参考
            <a href="#HFSPlusDates">HFS+ Dates</a> 。</dd>
            
            <dt><code>checkedDate</code></dt>
            
            <dd>检查时间；通常由应用程序使用。比如Disk First
            Aid。</dd>
            
            <dt><code>fileCount</code></dt>
            
            <dd>文件总数，不包括special
            files。它等于catalog file的file records数。</dd>
            
            <dt><code>folderCount</code></dt>
            
            <dd>目录总数，不包括special
            files。它等于catalog file的folder records数减1。</dd>
            
            <dt><code>blockSize</code></dt>
            
            <dd>allocation block 大小，单位bytes.</dd>
            
            <dt><code>totalBlocks</code></dt>
            
            <dd>分区总的blocks数。</dd>
            
            <dt><code>freeBlocks</code></dt>
            
            <dd>空闲blocks数。</dd>
            
            <dt><code>nextAllocation</code></dt>
            
            <dd>下一次分配block的位置。仅提示作用，具体参考<a href="#AllocationFile">Allocation
            File</a> 一节</dd>
            
            <dt><code>rsrcClumpSize</code></dt>
            
            <dd>The default <a href="#Clump">clump
            size</a> for resource forks, in bytes. This is a hint to the
            implementation as to the size by which a growing file should
            be extended. All Apple implementations to date ignore the
            <code>rsrcClumpSize</code> and use
            <code>dataClumpSize</code> for both data and resource
            forks.</dd>
            
            <dt><code>dataClumpSize</code></dt>
            
            <dd>The default <a href="#Clump">clump
            size</a> for data forks, in bytes. This is a hint to the
            implementation as to the size by which a growing file should
            be extended. All Apple implementations to date ignore the
            <code>rsrcClumpSize</code> and use
            <code>dataClumpSize</code> for both data and resource
            forks.</dd>
            
            <dt><code>nextCatalogID</code></dt>
            
            <dd>一个个未使用的CNID，参考
            <a href="#CatalogFile">Catalog File</a> 对catalog ID的描述。</dd>
            
            <dt><code>writeCount</code></dt>
            
            <dd>每次卷挂载后都会增加一次。系统会根据此标志位判断该卷是否更改。
            这种情况可发生在弹出或掉线等意外情况。如果用户用其它工具修改了HFS+的卷，
            应该确保更新<code>writeCount</code>，特别是添加或删除一些项时尤为重要。
            </dd>
            
            <dt><code>encodingsBitmap</code></dt>
            
            <dd>该字段用于跟踪分区上使用的文本编码。
               能够优化一些未使用Unicode编码格式。见
            <a href="#TextEncodings">Text Encoding</a>
            一节</dd>
            
            <dt><a name="VolumeFinderInfo"></a><code>finderInfo</code></dt>
            
            <dd>
			This array of 32-bit items contains information used by the Mac OS
            Finder, and the system software boot process.<br><br>
            
            <code>finderInfo[0]</code> contains the directory ID of the
            directory containing the bootable system (for example, the
            System Folder in Mac OS 8 or 9, or <code>/System/Library/CoreServices</code>
            in Mac OS X). It is zero if there is no bootable system on the volume.
            This value is typically equal to either <code>finderInfo[3]</code>
            or <code>finderInfo[5]</code>.<br><br>
            
            <code>finderInfo[1]</code> contains the parent directory ID of
            the startup application (for example, Finder), or zero if the volume
            is not bootable.<br><br>
            
            <code>finderInfo[2]</code> contains the directory ID of a directory
            whose window should be displayed in the Finder when the volume is
            mounted, or zero if no directory window should be opened.  In
            traditional Mac OS, this is the first in a linked list of windows
            to open; the <code>frOpenChain</code> field of the directory's
            <a href="#FinderInfo">Finder Info</a> contains the next directory ID
            in the list.  The open window list is deprecated.  The Mac OS X
            Finder will open this directory's window, but ignores the rest
            of the open window list. The Mac OS X Finder does not modify
            this field.<br><br>
            
            <code>finderInfo[3]</code> contains the directory ID of a bootable
            Mac OS 8 or 9 System Folder, or zero if there isn't one.<br><br>
            
            <code>finderInfo[4]</code> is <a href="#ReservedAndPadFields">保留</a>.<br><br>
            
            <code>finderInfo[5]</code> contains the directory ID of a bootable
            Mac OS X system (the <code>/System/Library/CoreServices</code>
            directory), or zero if there is no bootable Mac OS X system on
            the volume.<br><br>
            
            <code>finderInfo[6]</code> and <code>finderInfo[7]</code> are
            used by Mac OS X to contain a 64-bit unique volume identifier.
            One use of this identifier is for tracking whether a given
            volume's ownership (user ID) information should be honored.
            These elements may be zero if no such identifier has been
            created for the volume.</dd>
            
            <dt><code>allocationFile</code></dt>
            
            <dd>allocation file 的 data fork。</dd>
            
            <dt><code>extentsFile</code></dt>
            
            <dd>extents file 的 data fork。</dd>
            
            <dt><code>catalogFile</code></dt>
            
            <dd>catalog file 的 data fork。</dd>
            
            <dt><code>attributesFile</code></dt>
            
            <dd>attributes file 的 data fork。</dd>
            
            <dt><code>startupFile</code></dt>
            
            <dd>startup file 的 data fork。</dd>
         </dl>
         
         <h3><a name="VolumeAttributes"></a>Volume Attributes</h3>
         
         <p><code>attributes</code> 域的每一位有特殊意义。见下表</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>enum {
    /* Bits 0-6 are reserved */
    kHFSVolumeHardwareLockBit       =  7,
    kHFSVolumeUnmountedBit          =  8,
    kHFSVolumeSparedBlocksBit       =  9,
    kHFSVolumeNoCacheRequiredBit    = 10,
    kHFSBootVolumeInconsistentBit   = 11,
    kHFSCatalogNodeIDsReusedBit     = 12,
    kHFSVolumeJournaledBit          = 13,
    /* Bit 14 is reserved */
    kHFSVolumeSoftwareLockBit       = 15
    /* Bits 16-31 are reserved */
};</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>每一位的意义如下:</p>
         
         <dl>
            <dt>bits 0-7</dt>
            
            <dd>
            <a href="#ReservedAndPadFields">保留</a> </dd>
            
            <dt><code>kHFSVolumeUnmountedBit</code> (bit 8)</dt>
            
            <dd>该位设置时，表示上次推出时磁盘已刷新。通常它是unmount实现最后一步操作。如果在加载时发现此位未设置，
            应该先执行一次
            <a href="#VolumeConsistencyChecks">有效性检测</a> 操作</dd>
            
            <dt><code>kHFSVolumeSparedBlocksBit</code> (bit 9)</dt>
            
            <dd>此位设置表示在extents overflow file 有坏道文件。 (belonging to file
            ID <code>kHFSBadBlockFileID</code>). See
            <a href="#BadBlockFile">Bad Block File</a> for details.</dd>
            
            <dt><code>kHFSVolumeNoCacheRequiredBit</code> (bit 10)</dt>
            
            <dd>此位设置表示该卷不需要Cache。比如像基于 RAM 或 ROM 的磁盘并不需要需要缓存。</dd>
            
            <dt><code>kHFSBootVolumeInconsistentBit</code> (bit 11)</dt>
            
            <dd>This bit is similar to
            <code>kHFSVolumeUnmountedBit</code>, but inverted in
            meaning. An implementation must set this bit on the media
            when it mounts a volume for writing. An implementation
            must clear this bit on the media as the last step of
            unmounting a writable volume, after all other volume
            information has been flushed. If an implementation is
            asked to mount a volume where this bit is set, it must
            assume the volume is inconsistent, and do appropriate
            <a href="#VolumeConsistencyChecks">consistency
            checking</a> before using the volume.</dd>
            
            <dt><code>kHFSCatalogNodeIDsReusedBit</code> (bit 12)</dt>
            
            <dd>This bit is set when the <code>nextCatalogID</code>
            field overflows 32 bits, forcing smaller <a href="#CNID">catalog node IDs</a> to be reused.  When this
            bit is set, it is common (and not an error) for catalog
            records to exist with IDs greater than or equal to
            <code>nextCatalogID</code>.  If this bit is set, you must
            ensure that IDs assigned to newly created catalog records do
            not conflict with IDs used by existing records.</dd>
            
            <dt><code>kHFSVolumeJournaledBit</code> (bit 13)</dt>
            
            <dd>如果设置此位，表示该卷启用了<a href="#Journal">
            日志</a>，并可使用 <code>journalInfoBlock</code>
            域</dd>
            
            <dt>bit 14</dt>
            
            <dd>
            <a href="#ReservedAndPadFields">保留</a>.</dd>
            
            <dt><code>kHFSVolumeSoftwareLockBit</code> (bit 15)</dt>
            
            <dd>This bit is set if the volume is write-protected due
            to a software setting. Any implementations must refuse to
            write to a volume with this bit set. This flag is
            especially useful for write-protecting a volume on a
            media that cannot be write-protected otherwise, or for
            protecting an individual partition on a partitioned
            device.</dd>
            
            <dt>bits 16-31</dt>
            
            <dd>An implementation must treat these bits as
            <a href="#ReservedAndPadFields">保留</a>.</dd>
         </dl>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  Mac OS X versions 10.0 to 10.3 don't properly honor
                  <code>kHFSVolumeSoftwareLockBit</code>. They incorrectly
                  allow such volumes to be modified.  This bug is expected
                  to be fixed in a future version of Mac OS X. (r. 3507614)</p>
</td></tr></tbody></table></center>
                  
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  An implementation may keep a copy of the attributes
                  in memory and use bits 0-7 for its own runtime
                  flags. As an example, Mac OS uses bit 7,
                  <code>kHFSVolumeHardwareLockBit</code>, to indicate
                  that the volume is write-protected due to some
                  hardware setting.</p>
                  </td></tr></tbody></table></center>
                  
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  The existence of two volume consistency bits
                  (<code>kHFSVolumeUnmountedBit</code> and
                  <code>kHFSBootVolumeInconsistentBit</code>)
                  deserves an explanation. Macintosh ROMs check the
                  consistency of a boot volume if
                  <code>kHFSVolumeUnmountedBit</code> is clear. The
                  ROM-based check is very slow, annoyingly so. This
                  checking code was significantly optimized in Mac OS
                  7.6. To prevent the ROM check from being used, Mac
                  OS 7.6 (and higher) leaves the original consistency
                  check bit (<code>kHFSVolumeUnmountedBit</code>) set
                  at all times. Instead, an alternative flag
                  (<code>kHFSBootVolumeInconsistentBit</code>) is
                  used to signal that the disk needs a consistency
                  check.</p>
                  </td></tr></tbody></table></center>
                  
  <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                
                  For the boot volume, the
                  <code>kHFSBootVolumeInconsistentBit</code> should
                  be used as described but
                  <code>kHFSVolumeUnmountedBit</code> should remain
                  set; for all other volumes, use the
                  <code>kHFSVolumeUnmountedBit</code> as described
                  but keep the
                  <code>kHFSBootVolumeInconsistentBit</code> clear.
                  This is an optimization that prevents the Mac OS
                  ROM from doing a very slow consistency check when
                  the boot volume is mounted since it only checks
                  <code>kHFSVolumeUnmountedBit</code>, and won't do a
                  consistency check; later on, the File Manager will
                  see the <code>kHFSBootVolumeInconsistentBit</code>
                  set and do a better, faster consistency check. (It
                  would be OK to always use both bits at the expense
                  of a slower Mac OS boot.)</p>
               </td></tr></tbody></table></center>
               
<p><a href="#top">返回顶部</a></p>


         <h2><a name="BTrees"></a>B-Trees</h2>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  关于B-tree算法的描述，参考<cite>Algorithms in
                  C</cite>, Robert Sedgewick, Addison-Wesley, 1992.
                  ISBN: 0201514257.</p>
                  
                  <p>许多书中描述的B-trees都是有N个key和N+1个pointers, 小于#X key的位于#X 
                  pointer 指向的子树；反之则是 #X+1 pointer。（如果相等，则取决于具体实现是用
                   #X 或 #X+1 指针）</p>
                  
                  <p>HFS 和 HFS+ 有轻微的不同；在一个给定的子树中，没有比根节点更小的key。 in a
                  given subtree, there are no keys less than the
                  first key of that subtree's root node.</p>
         </td></tr></tbody></table></center>
       
         
         <p>本章介绍了catalog, extents overflow, 和 attributes files用到的B-tree结构。
         B-tree存储在 data fork 中。每个文件中的B-tree都由位于volume header的
         <code><a href="tn1150.html">HFSPlusForkData</a></code>
         确定存储的空间。</p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  特殊文件没有resource fork，这时因为volume header没有存储其它
                  <code>HFSPlusForkData</code> 。 但是，B-tree本身也是可以保存
                  frok的，比如extents overflow file自己保存了它的扩展extente</p>
         </td></tr></tbody></table></center>
         
         <p>B-tree文件由许多固定大小的<b>nodes</b>, <b>nodes</b>包含了许多<b>records</b>，
         而 <b>records</b> 又包含了 <b>key</b> 和其它数据。B-tree的目的就是快速搜索到key和
         它对应的数据。所以它是按一定顺序存放的，并且key 就是用于顺序比较操作。</p>
         
         <p> <b>node size</b> (which is expressed in bytes) 必须是2的幂次，范围在 512 到 32,768。
         node的大小在B-tree创建出来时就已经确定了。而整个B-tree文件的大小等于node size乘以node数量。</p>
         
         <p>总共有4种不同类型的node。</p>
         
         <ul>
            <li>每个B-tree包含一个 <b>header node</b>. 
            header node 问题 B-tree 的第一个node。它包含了一些信息用于找到其它node。</li>
            
            <li><b>Map nodes</b> 包含 <b>map records</b>, 是header node中map record不够用时的附加部分，用于保存所有分配信息
            (可标识出B-tree那些结点是可用的) 。</li>
            
            <li><b>Index nodes</b> 包含 <b>pointer records</b>, 它决定了B树的整体结构。</li>
            
            <li><b>Leaf nodes</b> 包含 <b>data records</b>，它与某个key对应，B-tree中每个key都是唯一的。</li>
         </ul>
         
         <p>所有的结点都有一个相同的结构，描述如下。</p>
         
         <h3>Node Structure</h3>
         
         <p>Nodes都是由数字（偏移）来找到的。结点号乘以每个节点大小即可得到在文件中的偏移。
         每个node都有一个相同的结构，保存了三个重要的部分：node descriptor，node后面的record offset链表和包含的records。
         图2 显示了它的组织结构。</p>
         
         
         
         <center><img src="tn1150_002.gif" alt="Structure of a node" width="230" height="312" align="bottom">
         <p><b>图 2</b>. node的结构</p></center>
         
         <p> <b>node descriptor</b> 即包含了一些node的基本信息，又作为一个双向链表使用。
         <code>BTNodeDescriptor</code> 描述了此结构。</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct BTNodeDescriptor {
    UInt32    fLink;
    UInt32    bLink;
    SInt8     kind;
    UInt8     height;
    UInt16    numRecords;
    UInt16    reserved;
};
typedef struct BTNodeDescriptor BTNodeDescriptor;</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>结构中各个域的作用如下：</p>
         
         <dl>
            <dt><code>fLink</code></dt>
            
            <dd>下一个节点的节点号，如果是最后节点，则为0.</dd>
            
            <dt><code>bLink</code></dt>
            
            <dd>前一个节点的节点号，如果是第一个节点，则为0.</dd>
            
            <dt><code>kind</code></dt>
            
            <dd>node的类型。共有4种类型，见下表。</dd>
            
            <dt><code>height</code></dt>
            
            <dd>node的高度，或在B-tree中的深度。header node的高度为0，叶节点的高度为1，其它（索引节点）的高度比子节点高1.
            如果只有header node，那么B-tree的高度为0；否则是节点中最高的高度。</dd>
            
            <dt><code>numRecords</code></dt>
            
            <dd>node里records的数量</dd>
            
            <dt><code>reserved</code></dt>
            
            <dd>
            <a href="#ReservedAndPadFields">保留</a> </dd>
         </dl>
         
         <p>因为 node descriptor 总是占用14字节 (
         <code>sizeof(BTNodeDescriptor)</code>) ，所以在
         <b>list of records</b> 总是会有一个指向14字节后的record。每个record的大小是不固定的。</p>
         
         <p>records 都是通过 <b>list of record
         offsets</b> 来访问的。每个offset都是一个 <code>UInt16</code>。从上图可看到，它是反向存储的。</p>
         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  <b>list of record offsets</b> 至少有1个record的记录。
                  如果node中没有空间存放更多record时，则它会指向它自己（Entry？）的位置。</p>
         </td></tr></tbody></table></center>
         
         <p> <code>kind</code> 表示了些node的类型，竟而说明了它包含records的类型，也就决定了B-tree的组织。
         下面是4种可能的情况。</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>enum {
    kBTLeafNode       = -1,
    kBTIndexNode      =  0,
    kBTHeaderNode     =  1,
    kBTMapNode        =  2
};</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>节点的类型对于B-tree非常重要。叶节点只会包含data records。索引节点
         只会包含指针。Map节点只会包含map records。头节点只会包含一个header record，
         reserved record, 和 map record。每个类型具体的描述会在下节。</p>
         
         <h3><a name="HeaderNode"></a>Header Nodes</h3>
         
         <p>第一个 node (node 0) 总是 header node，它包含了很多重要信息。
         共3个记录在此node里。第一个是 B-tree header record。第二个是 user data record，
         长度固定128字节。最后一个是 B-tree map record; 它占据了后面所有空间。
         图3 显示了 header node。</p>
         
         <center>
         <img src="tn1150_003.png" alt="Header node" width="198" height="306" align="bottom">
         <p><b>Figure 3</b> Header node 结构</p>
         </center>
         
         <p>header node 的 <code>fLink</code> 是第一个map node的node number。如果没有map node则为0.
         <code>bLink</code> 总是设置为0.
         </p>
         
         <h4><a name="HeaderRecord"></a>Header Record</h4>
         
         <p>B-tree 的 <b>header record</b> 包含的内容包括总大小，最大key length，
         以及第一个后最后一个叶节点的node。它的保存结构是 <code>BTHeaderRec</code>。</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct BTHeaderRec {
    UInt16    treeDepth;
    UInt32    rootNode;
    UInt32    leafRecords;
    UInt32    firstLeafNode;
    UInt32    lastLeafNode;
    UInt16    nodeSize;
    UInt16    maxKeyLength;
    UInt32    totalNodes;
    UInt32    freeNodes;
    UInt16    reserved1;
    UInt32    clumpSize;      // misaligned
    UInt8     btreeType;
    UInt8     keyCompareType;
    UInt32    attributes;     // long aligned again
    UInt32    reserved3[16];
};
typedef struct BTHeaderRec BTHeaderRec;</pre>
    </td>
</tr>
</tbody></table></center>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  The root node can be a leaf node (in the case where
                  there is only a single leaf node, and therefore no
                  index nodes, as might happen with the catalog file
                  on a newly initialized volume). If a tree has no
                  leaf nodes (like the extents overflow file on a
                  newly initialized volume), the
                  <code>firstLeafNode</code>,
                  <code>lastLeafNode</code>, and
                  <code>rootNode</code> fields will all be zero. If
                  there is only one leaf node (as may be the case
                  with the catalog file on a newly initialized
                  volume), <code>firstLeafNode</code>,
                  <code>lastLeafNode</code>, and
                  <code>rootNode</code> will all have the same value
                  (i.e., the node number of the sole leaf node). The
                  <code>firstLeafNode</code> and
                  <code>lastLeafNode</code> fields just make it easy
                  to walk through all the leaf nodes by just
                  following <code>fLink/bLink</code> fields.</p>
         </td></tr></tbody></table></center>
         
         <p>结构中各个域的作用如下：</p>
         
         <dl>
            <dt><code>treeDepth</code></dt>
            
            <dd>当前B-tree的深度。总是等于root node的<code>height</code>。</dd>
            
            <dt><code>rootNode</code></dt>
            
            <dd>root node number, 它是B-tree的根index node。参考
            <a href="#IndexNodes">Index Nodes</a> 获取更多细节。
            有一种可能 <code>rootNode</code> 成为叶节点，细节参考 <a href="http://developer.apple.com/techpubs/mac/Files/">Inside
            Macintosh: Files</a>, pp. 2-69。</dd>
            
            <dt><code>leafRecords</code></dt>
            
            <dd>所有叶节点包含records的数量。</dd>
            
            <dt><code>firstLeafNode</code></dt>
            
            <dd>第一个叶节点的node number。如果为0，则表示没有。</dd>
            
            <dt><code>lastLeafNode</code></dt>
            
            <dd>最后一个叶节点的node number。</dd>
            
            <dt><code>nodeSize</code></dt>
            
            <dd>每个node的大小。必须是2的幂次，范围在512到32,768。</dd>
            
            <dt><code>maxKeyLength</code></dt>
            
            <dd>索引和叶节点中key的最大长度。
            HFSVolumes.h has the <code>maxKeyLength</code> values for
            the catalog and extents files for both HFS and HFS+
            (<code>kHFSPlusExtentKeyMaximumLength</code>,
            <code>kHFSExtentKeyMaximumLength</code>,
            <code>kHFSPlusCatalogKeyMaximumLength</code>,
            <code>kHFSCatalogKeyMaximumLength</code>). The maximum
            key length for the attributes B-tree will probably be a
            little larger than for the catalog file. 通常，<code>maxKeyLength</code>
            会比较小以便一个node可以容纳2个最大的key和一个node descriptor，以及offsets list。</dd>
            
            <dt><code>totalNodes</code></dt>
            
            <dd>B-tree中所有node的总数（包括已使用和未使用）。B-tree文件大大小等于totalNodes*nodeSize.</dd>
            
            <dt><code>freeNodes</code></dt>
            
            <dd>未使用node的数量。</dd>
            
            <dt><code>reserved1</code></dt>
            
            <dd>
            <a href="#ReservedAndPadFields">保留</a> </dd>
            
            <dt><code>clumpSize</code></dt>
            
            <dd>Ignored for HFS+ B-trees. The
            <code>clumpSize</code> field of the
            <code><a href="tn1150.html">HFSPlusForkData</a></code>
            record is used instead. For maximum compatibility, an
            implementation should probably set the
            <code>clumpSize</code> in the node descriptor to the same
            value as the <code>clumpSize</code> in the
            <code>HFSPlusForkData</code> when initializing a volume.
            Otherwise, it should treat the header records's
            <code>clumpSize</code> as reserved.</dd>
            
            <dt><code>btreeType</code></dt>
            
            <dd>储存的是
            <code>BTreeTypes</code>:
<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>enum BTreeTypes{
    kHFSBTreeType           =   0,      // control file
    kUserBTreeType          = 128,      // user btree type starts from 128
    kReservedBTreeType      = 255
};</pre>
    </td>
</tr>
</tbody></table></center>
            <p>此域的值必须等于 
            <a href="#CatalogFile">catalog</a>, <a href="#ExtentsOverflowFile">extents</a>, 和 <a href="#AttributesFile">attributes</a> 的B-trees <code>kHFSBTreeType</code>.  
            以及 <a href="#HotFile">hot file</a> 的B-tree <code>kUserBTreeType</code>。1-127的值历史上曾用于Mac OS 9的系统软件上。</p>
            </dd>
            
            <dt><code>keyCompareType</code></dt>
            
            <dd>在 <a href="#HFSX">HFSX</a> 卷上, 在catalog B-tree header 
            上定义了比较key的顺序（大小写敏感或不敏感）。其它情况都用作
            <a href="#ReservedAndPadFields">保留</a> 。

            <table>
            	<tbody><tr><th>常量名					</th><th>值				</th><th>意义</th></tr>
            	<tr><td scope="row"><code>kHFSCaseFolding</code>	</td><td><code>0xCF</code>	</td><td>大小写不敏感</td></tr>
            	<tr><td scope="row"><code>kHFSBinaryCompare</code>	</td><td><code>0xBC</code>	</td><td>大小写敏感</td></tr>
            </tbody></table>
            </dd>
            
            <dt><code>attributes</code></dt>
            
            <dd>一些属性，值见下表。</dd>
            
            <dt><code>reserved3</code></dt>
            
            <dd>            <a href="#ReservedAndPadFields">保留</a>。</dd>
         </dl>
         
         <p>header record中 <code>attributes</code> 的取值。</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>enum {
    kBTBadCloseMask           = 0x00000001,
    kBTBigKeysMask            = 0x00000002,
    kBTVariableIndexKeysMask  = 0x00000004
};</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>每个位的意义如下:</p>
         
         <dl>
            <dt><code>kBTBadCloseMask</code></dt>
            
            <dd>该位表示B-tree没有正确关闭。在HFS+没有使用。
            <a href="#ReservedAndPadFields">保留</a>.</dd>
            
            <dt><code>kBTBigKeysMask</code></dt>
            
            <dd>If this bit is set, the <code>keyLength</code> field
            of the keys in index and leaf nodes is
            <code>UInt16</code>; otherwise, it is a
            <code>UInt8</code>. This bit must be set for all HFS+
            B-trees.</dd>
            
            <dt><code>kBTVariableIndexKeysMask</code></dt>
            
            <dd>If this bit is set, the keys in index nodes occupy
            the number of bytes indicated by their
            <code>keyLength</code> field; otherwise, the keys in
            index nodes always occupy <code>maxKeyLength</code>
            bytes. This bit must be set for the HFS+ Catalog
            B-tree, and cleared for the HFS+ Extents B-tree.</dd>
         </dl>
         
         <p>Bits not specified here must be treated as
         <a href="#ReservedAndPadFields">保留</a>.</p>
         
		<h4><a name="UserDataRecord"></a>User Data Record</h4>
         
		<p>header node的每二个record总是128字节。</p>
		
		<p>在HFS+的 <a href="#CatalogFile">catalog</a>, <a href="#ExtentsOverflowFile">extents</a>, 和 <a href="#AttributesFile">attributes</a> B-trees, 此位置用于 <a href="#ReservedAndPadFields">保留</a>. 而 <a href="#HotFile">hot file</a> B-tree, 该域包含了一些有关hot file的信息.</p>
         
         <h4>Map Record</h4>
         
         <p>此record是header node的第三个。<b>map record</b> 记录那些node是可用的，
         它每一位的表示与 <a href="#AllocationFile">allocation file</a>
         相同。</p>
         
         <p>除去node descriptor, header record, reserved
         record, 和 record offsets，共计有<code>nodeSize</code> - 256
         字节可供 map 使用。如果不能满足，map nodes 会选择储存在 additional
         allocation data.</p>
         
         <h3>Map Nodes</h3>
         
         <p>如果map nodes 使用了 additional allocation data，
         header descriptor 的 <code>fLink</code> 会指示下一个node的位置。</p>
         
         <p>每个map node都只包含 node descriptor 和一个map record。
         这些map record是header　node的map record的后继。它们的大小是
         nodeSize减去node　descriptor (14 bytes), 再减去２个offsets (4
		　bytes), 再减去２字节的空闲空间。所以，map　record的大小等于nodeSize
        减去20 bytes；这样它的大小就可以是４字节对齐。注意，record的起始不是４字节对齐
        的（14字节）。</p>
         
         <p>B-tree的map nodes按需分配。map nodes通过node　descriptors的<code>fLink</code> 
         来按链式储存。最后一个
         <code>fLink</code> 是０。<code>bLink</code>没有使用。
         </p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  Not using the <code>bLink</code> field is
                  consistent with the HFS volume format, but not
                  really consistent with the overall design.</p>
         </td></tr></tbody></table></center>
         
         <h3><a name="KeyedRecords"></a>Keyed Records</h3>
         
         <p>索引和叶节点有一个共同的结构。它包含一个 <code>keyLength</code>, 后面紧接着是 <b>key</b> 。</p>
         
         <p><code>keyLength</code>, 是 <code>UInt8</code> 或 <code>UInt16</code> 整数,
         由B-tree header record 的 <code>attributes</code> 决定。
         <code>keyLength</code> 储存了此key record的大小，不包括它自己。</p>
         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  所有 HFS+ B-trees 的 key length 都是 <code>UInt16</code>。</p>
        </td></tr></tbody></table></center>
         
         <p>key 本身的长度与node的类型和B-tree attributes有关。叶节点的key由<code>keyLength</code>
         决定；而索引节点是由B-tree <a href="#HeaderRecord">header record</a> 
          的attribute中的<code>kBTVariableIndexKeysMask</code>决定。如果此位没有设置，那么
          它就由<code>maxKeyLength</code> 决定。如果设置了，则是由 <code>keyLength</code>。 </p>
         
         <p>key后面的则是 record's data。data的格式也取决于 node type，
         下两节将会介绍。data总是2字节对齐的，所以，如果<code>keyLength</code>
         加上key的大小为奇数，则必须插入一个padding位。</p>
         
         <h3><a name="IndexNodes"></a>Index Nodes</h3>
         
         <p>索引节点的records称之为<b>pointer
         records</b>. 它同样有一个<code>keyLength</code>, 一个key, 和一个
         <code>UInt32</code>的node number。pointer record中的node number
         称之为 <b>child node</b>。一个索引可能有2个或更多孩子。</p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  A root node does not need to exist (if the tree is
                  empty). And even if one does exist, it need not
                  be an index node (i.e., it could be a leaf node
                  if all the records fit in a single node).</p>
         </td></tr></tbody></table></center>
         
         <h3>叶节点</h3>
         
         <p>B-tree的最下面称之为 <b>leaf nodes</b>，它没有pointer records,
         取而代之是 <b>data records</b> 。data records 同样包含一个 <code>keyLength</code>, 
         一个key, 和与此key关联的数据。data的长度不固定。</p>
         
         <p>在HFS+的B-tree中，在data rcecord中的数据就是HFS+保存文件的结构，比如
         <code>CatalogRecord</code>, <code>ExtentRecord</code>, 或
         <code>AttributeRecord</code>) 。</p>
         
         <h3><a name="SearchingForKeyedRecords"></a>搜索特定的key</h3>
         
         <p>B-tree的高度结构化使得搜索，插入和删除都非常有效率。主要采影响的是
         与key相连的records。下面是操作索引和叶节点的顺序：</p>
         
         <ul>
            <li>每个node中的Keyed records必须按升序排列。</li>
            
            <li>每一级 (高度相同) 的node都是由 <code>fLink</code> 和 <code>bLink</code>
            串联着。node里包含了最小的key的node必须出现在链首，即 <code>bLink</code> 
            为空。反之则最后， <code>fLink</code> 为空。</li>
            
            <li>对任一一个node，它里面包含的所有key都比一下个node
            (<code>fLink</code> 指向的)的小，比上一个node(<code>bLink</code> 指向)的大。</li>
         </ul>
         
         <p>按照这种方式排序，使用在B-tree中搜索某个key非常容易。
         图4展示了一种假想的情况。</p>
         
         <p>当我们在寻找某个 <b>search key</b> 时，我们从root node开始。
         从第一个record开始，找到一个大于等于serach key的最大record，然后到这个
         子node中继续搜索（假设是索引节点）；否则，转到它兄弟node继续。</p>
         
         <p>此过程最终会到达一个叶节点。如果这个叶节点的key等于serach key，
         那么我们就找到了。否则，它没有包含在该B-tree中。</p>
         
         
         
         <center><img src="tn1150_004.gif" width="361" height="182" align="bottom" alt="1150.4.gif"><p><b>Figure 4</b>. A sample B-Tree</p></center>
         
         <h3>HFS 和 HFS+ B-Trees 比较</h3>
         
         <p>HFS+ 的B-tree
         结构和<a href="http://developer.apple.com/techpubs/mac/Files/Files-104.html">HFS</a>很相似。
         有三处主要的不同：nodes的大小，索引node的key的size，和key length(UInt8 vs.
         UInt16)。</p>
         
         <h4><a name="NodeSizes"></a>node 大小</h4>
         
         <p>HFS B-tree 的nodes 总是512字节。</p>
         
         <p>HFS+ B-tree 的nodes大小由header node中的 (<code>nodeSize</code>) 决定。</p>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  The header node is always located at the start of
                  the B-tree, so you can find it without knowing the
                  B-tree node size.</p>
         </td></tr></tbody></table></center>
         
         <p>HFS+ 使用下面默认的node大小：</p>
         
         <ul>
            <li>4 KB (8KB in Mac OS X) for the catalog file</li>
            <li>1 KB (4KB in Mac OS X) for the extents overflow file</li>
            <li>4 KB for the attributes file</li>
         </ul>
         
         <p>These sizes are set when the volume is initialized and
         cannot be easily changed. It is legal to initialize an HFS+ volume with different node sizes, but the node sizes
         must be large enough for an index node to contain two keys
         of maximum size (plus the other overhead such as a node
         descriptor, record offsets, and pointers to children).</p>
         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  The node size of the catalog file must be at least
                  <code>kHFSPlusCatalogMinNodeSize</code> (4096).</p>
         </td></tr></tbody></table></center>
                  
                  <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  The node size of the attributes file must be at
                  least <code>kHFSPlusAttrMinNodeSize</code> (4096).</p>
         </td></tr></tbody></table></center>
         
         <h4>索引节点中的key size</h4>
         
         <p>In an HFS B-tree, all of the keys in an index node occupy
         a fixed amount of space: the maximum key length for that
         B-tree. This simplifies the algorithms for inserting and
         deleting records because, within an index node, one key can
         be replaced by another key without worrying whether there is
         adequate room for the new key. However, it is also somewhat
         wasteful when the keys are variable length (such as in the
         catalog file, where the key length varies with the length of
         the file name).</p>
         
         <p>In an HFS+ B-tree, the keys in an index node are
         allowed to vary in size. This complicates the algorithms for
         inserting and deleting records, but reduces wasted space
         when the length of a key can vary (such as in the catalog
         file). It also means that the number of keys in an index
         node will vary with the actual size of the keys.</p><br>

<p><a href="#top">返回顶部</a></p>


         <h2><a name="CatalogFile"></a>Catalog File</h2>
         
         <p>HFS+ 使用 catalog file 来组织文件和目录的信息。同样是由
         header node， index node， leaf
         nodes, 和 (如果可能) map nodes。Catalog file的第一个extent在
          volume header中。在catalog file的header node里包含了该B-tree的root node number。
          因此找到root node并按<a href="#SearchingForKeyedRecords">上节</a>的方法搜索keys了。
        </p>
         
         <p>B-Trees一章介绍了HFS+ B-tree的
         <a href="#NodeSizes">node size</a>. catalog file
         的node size至少是4 KB。
         (<code>kHFSPlusCatalogMinNodeSize</code>).</p>
         
         <p><a name="CNID"></a>每个file或folder都分区了唯一一个catalog node ID (CNID)。
         对于目录，CNID又称之为<b>folder ID</b>, directory ID, 或 dirID;
         对于文件，称之为<b>file ID</b>。而目录或文件，它的parent ID 就是父目录的 CNID。</p>
         
         <p>catalog node ID 的定义表示为
         <code>CatalogNodeID</code>。</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>typedef UInt32 HFSCatalogNodeID;</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>前16个CNID由苹果保留，它们定义如下：</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>enum {
    kHFSRootParentID            = 1,
    kHFSRootFolderID            = 2,
    kHFSExtentsFileID           = 3,
    kHFSCatalogFileID           = 4,
    kHFSBadBlockFileID          = 5,
    kHFSAllocationFileID        = 6,
    kHFSStartupFileID           = 7,
    kHFSAttributesFileID        = 8,
    kHFSRepairCatalogFileID     = 14,
    kHFSBogusExtentFileID       = 15,
    kHFSFirstUserCatalogNodeID  = 16
};</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>定义意义如下：</p>
         
         <dl>
            <dt><code>kHFSRootParentID</code></dt>
            
            <dd>Parent ID of the root folder.</dd>
            
            <dt><code>kHFSRootFolderID</code></dt>
            
            <dd>Folder ID of the root folder.</dd>
            
            <dt><code>kHFSExtentsFileID</code></dt>
            
            <dd>File ID of the <a href="#ExtentsOverflowFile">extents
            overflow file</a>.</dd>
            
            <dt><code>kHFSCatalogFileID</code></dt>
            
            <dd>File ID of the <a href="#CatalogFile">catalog
            file</a>.</dd>
            
            <dt><code>kHFSBadBlockFileID</code></dt>
            
            <dd>File ID of the <a href="#BadBlockFile">bad block
            file</a>. The bad block file is not a file in the same
            sense as a special file and a user file. See
            <a href="#BadBlockFile">Bad Block File</a> for details.</dd>
            
            <dt><code>kHFSAllocationFileID</code></dt>
            
            <dd>File ID of the <a href="#AllocationFile">allocation
            file</a> (introduced with HFS+).</dd>
            
            <dt><code>kHFSStartupFileID</code></dt>
            
            <dd>File ID of the <a href="#StartupFile">startup
            file</a> (introduced with HFS+).</dd>
            
            <dt><code>kHFSAttributesFileID</code></dt>
            
            <dd>File ID of the <a href="#AttributesFile">attributes
            file</a> (introduced with HFS+).</dd>
            
            <dt><code>kHFSRepairCatalogFileID</code></dt>
            
            <dd>Used temporarily by <code>fsck_hfs</code> when
            rebuilding the catalog file.</dd>
            
            <dt><code>kHFSBogusExtentFileID</code></dt>
            
            <dd>Used temporarily during <code>ExchangeFiles</code>
            operations.</dd>
            
            <dt><code>kHFSFirstUserCatalogNodeID</code></dt>
            
            <dd>First CNID available for use by user files and
            folders.</dd>
         </dl>
         
         <p>CNID等于0的情况永远不会出现。</p>
         
         <p>通常，CNID从
         <code>kHFSFirstUserCatalogNodeID</code>开始顺序分配。在2000年1月18日
         之前的HFS+版本，需要<a href="#VolumeHeader">volume header</a>的
         <code>nextCatalogID</code> 大于已使用的CNID （这样新的CNID就可以
         直接从它开始分配）。对于高文件创建的系统（如服务器），可能会出现CNID用尽的情况。</p>

         <p>HFS+ 现在能使CNID折返以重新使用。 <a href="#VolumeHeader">
         volume header</a> 的 <code>kHFSCatalogNodeIDsReusedBit</code> 位标识出这种情况。
         当出现这种情况时，<code>nextCatalogID</code> 就不会再使用了。</p>

         <p>When <code>kHFSCatalogNodeIDsReusedBit</code> is set,
         <code>nextCatalogID</code> may still be used as a hint for the
         CNID to assign to newly created files or directories, but the
         implementation must verify that CNID is not currently in use
         (and pick another value if it is in use). When CNID number
         <code>nextCatalogID</code> is already in use, an implementation
         could just increment <code>nextCatalogID</code> until it finds
         a CNID that is not in use.  If <code>nextCatalogID</code>
         overflows to zero, <code>kHFSCatalogNodeIDsReusedBit</code>
         must be set and <code>nextCatalogID</code> set to
         <code>kHFSFirstUserCatalogNodeID</code> (to avoid using any
         reserved CNID values).</p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>
                  Mac OS X versions 10.2 and later, and all versions
                  of Mac OS 9 support
                  <code>kHFSCatalogNodeIDsReusedBit</code>.</p>
</td></tr></tbody></table></center>

         <p> catalog file 的 B-tree file 仍然继承之上节的
         <a href="#BTrees">B-Trees</a>。你只需要了解2个数据所表示的意义：</p>
         
         <ol>
            <li>索引和叶节点使用的key</li>
            
            <li>叶节点中数据的格式(file,
            folder, and thread records).</li>
         </ol>
         
         <h3>Catalog File Key</h3>
         
         <p>每个文件，目录或thread record，都包含一个父目录的<a href="#CNID">CNID</a>
         以及自己的名字。该结构描述如 <code>HFSPlusCatalogKey</code> 。</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct HFSPlusCatalogKey {
    UInt16              keyLength;
    HFSCatalogNodeID    parentID;
    HFSUniStr255        nodeName;
};
typedef struct HFSPlusCatalogKey HFSPlusCatalogKey;</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>结构中各个域的作用如下：</p>
         
         <dl>
            <dt><code>keyLength</code></dt>
            
            <dd> <code>keyLength</code> 域用在所有
            <a href="#KeyedRecords">keyed records</a> 中。
            The catalog file, in common with all HFS+ B-trees,
            uses a large key length (<code>UInt16</code>).</dd>
            
            <dt><code>parentID</code></dt>
            
            <dd>文件或目录的父CNID。 For
            thread records, this is the <a href="#CNID">CNID</a> of the
            file or folder itself.</dd>
            
            <dt><code>nodeName</code></dt>
            
            <dd>Unicode字符，
            <a href="#CanonicalDecomposition">完全分解和规范顺序</a>. 
            它是文件或目录的名字。对于thread records, 为空。</dd>
         </dl>
         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  The length of the key varies with the length of the
                  string stored in the <code>nodeName</code> field;
                  it occupies only the number of bytes required to
                  hold the name. The <code>keyLength</code> field
                  determines the actual length of the key; it varies
                  between
                  <code>kHFSPlusCatalogKeyMinimumLength</code> (6) to
                  <code>kHFSPlusCatalogKeyMaximumLength</code> (516).</p>
               </td></tr></tbody></table></center>
               
              
  <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  The catalog file key mirrors the standard way you
                  specify a file or folder with the Mac OS File
                  Manager programming interface, with the exception
                  of the volume reference number, which determines
                  which volume's catalog to search.</p>
         </td></tr></tbody></table></center>
         
         <p>Catalog file keys 先比较
         <code>parentID</code>，然后是 <code>nodeName</code>。
         <code>parentID</code> 的比较是32-bit
         整数。对于大小写敏感的 <a href="#HFSX">HFSX</a>，<code>nodeName</code> 的
         比较是一系列的无符号的16-bit整数。对于大小写不敏感的
         HFSX 和 HFS+ 卷，<code>nodeName</code>的比较在
         <a href="#StringComparisonAlgorithm">Case-Insensitive String
         Comparison Algorithm</a>  一节描述。</p>
         
         <p>更多使用catalog keys搜索文件，目录和thread records，参考<a href="#CatalogTreeUsage">Catalog Tree
         Usage</a>.</p>
         
         <h3>Catalog File Data</h3>
         
         <p>catalog file的叶节点可保护4种不同类型的data records:</p>
         
         <ol>
            <li> <b>folder record</b> 包含的是folder的数据。</li>
            
            <li> <b>file record</b> 包含的是file的数据。</li>
            
            <li> <b>folder thread record</b> 提供了一个连接从目录到它的父目录，
            这样这你就可以通过folder ID找到这个folder了。</li>
            
            <li> <b>file thread record</b> 提供了一个连接从文件到它的父目录，
            这样这你就可以通过file ID找到这个文件了。</li>
         </ol>
         
         <p>每个record都是以<code>recordType</code>域开始，
         <code>recordType</code> 可能包含下面常量的一种：</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>enum {
    kHFSPlusFolderRecord        = 0x0001,
    kHFSPlusFileRecord          = 0x0002,
    kHFSPlusFolderThreadRecord  = 0x0003,
    kHFSPlusFileThreadRecord    = 0x0004
};</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>意义如下：</p>
         
         <dl>
            <dt><code>kHFSPlusFolderRecord</code></dt>
            
            <dd>这是一个
            <a href="#CatalogFolderRecord">folder record</a>。你可以用
             <code>HFSPlusCatalogFolder</code> 来解析数据。</dd>
            
            <dt><code>kHFSPlusFileRecord</code></dt>
            
            <dd>这是一个 <a href="#CatalogFileRecord">file
            record</a>. 你可以用
            <code>HFSPlusCatalogFile</code> 来解析数据。</dd>
            
            <dt><code>kHFSPlusFolderThreadRecord</code></dt>
            
            <dd>这是一个
            <a href="#CatalogThreadRecord">thread record</a>. 你可以用 <code>HFSPlusCatalogThread</code> 来解析数据。</dd>
            
            <dt><code>kHFSPlusFileThreadRecord</code></dt>
            
            <dd>这是一个
            <a href="#CatalogThreadRecord">thread record</a>. 你可以用  <code>HFSPlusCatalogThread</code> 来解析数据。</dd>
         </dl>
         
         <p>后面三节将分别描述folder, file, 和
         thread records的细节。</p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  The position of the <code>recordType</code> field,
                  and the constants chosen for the various record
                  types, are especially useful if you're writing
                  common code to handle HFS and HFS+ volumes.
                  </p>
                  
                  <p>In HFS, the record type field is one byte, but
                  it's always followed by a one-byte reserved field
                  whose value is always zero. In HFS+, the record
                  type field is two bytes. You can use the HFS+
                  two-byte record type to examine an HFS record if
                  you use the appropriate constants, as shown below.
                  </p>
                  </td></tr></tbody></table></center>
                  
           
         <center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>enum {
    kHFSFolderRecord            = 0x0100,
    kHFSFileRecord              = 0x0200,
    kHFSFolderThreadRecord      = 0x0300,
    kHFSFileThreadRecord        = 0x0400
};</pre>
    </td>
</tr>
</tbody></table></center>
                       
                  
                  <p>The values have the following meaning:</p>
                  
                  <dl>
                     <dt><code>kHFSFolderRecord</code></dt>
                     
                     <dd>This record is an HFS folder record. You can
                     use the <code>HFSCatalogFolder</code> type to
                     interpret the data.</dd>
                     
                     <dt><code>kHFSFileRecord</code></dt>
                     
                     <dd>This record is an HFS file record. You can
                     use the <code>HFSCatalogFile</code> type to
                     interpret the data.</dd>
                     
                     <dt><code>kHFSFolderThreadRecord</code></dt>
                     
                     <dd>This record is an HFS folder thread record.
                     You can use the <code>HFSCatalogThread</code>
                     type to interpret the data.</dd>
                     
                     <dt><code>kHFSFileThreadRecord</code></dt>
                     
                     <dd>This record is an HFS file thread record.
                     You can use the <code>HFSCatalogThread</code>
                     type to interpret the data.</dd>
                  </dl>
               
         
         <h4><a name="CatalogFolderRecord"></a>Catalog Folder Records
         </h4>
         
         <p> catalog folder record 用来储存目录的信息。
         数据结构为
         <code>HFSPlusCatalogFolder</code> 。</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct HFSPlusCatalogFolder {
    SInt16              recordType;
    UInt16              flags;
    UInt32              valence;
    HFSCatalogNodeID    folderID;
    UInt32              createDate;
    UInt32              contentModDate;
    UInt32              attributeModDate;
    UInt32              accessDate;
    UInt32              backupDate;
    HFSPlusBSDInfo      permissions;
    FolderInfo          userInfo;
    ExtendedFolderInfo  finderInfo;
    UInt32              textEncoding;
    UInt32              reserved;
};
typedef struct HFSPlusCatalogFolder HFSPlusCatalogFolder;
&nbsp;</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>结构中各个域的作用如下：</p>
         
         <dl>
            <dt><code>recordType</code></dt>
            
            <dd>总是 <code>kHFSPlusFolderRecord</code>.</dd>
            
            <dt><code>flags</code></dt>
            
            <dd>没有使用，<a href="#ReservedAndPadFields">保留</a>。</dd>
            
            <dt><code>valence</code></dt>
            
            <dd>有多少文件和目录保存在该目录中。</dd>
         </dl>
         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  The traditional Mac OS File Manager programming
                  interfaces require folders to have a valence less
                  than 32,767. An implementation must enforce this
                  restriction if it wants the volume to be usable by
                  Mac OS. Values of 32,768 and larger are
                  problematic; 32,767 and smaller are OK. It's an
                  implementation restriction for the older Mac OS
                  APIs; items 32,768 and beyond would be unreachable
                  by <code>PBGetCatInfo</code>. As a practical
                  matter, many programs are likely to fails with
                  anywhere near that many items in a single folder.
                  So, the volume format allows more than 32,767 items
                  in a folder, but it's probably not a good idea to
                  exceed that limit right now.</p>
         </td></tr></tbody></table></center>
         
         <dl>
            <dt><code>folderID</code></dt>
            
            <dd> <a href="#CNID">CNID</a>。注意，folder reocrd的key中
            包含的是父目录的CNID，而不是这个CNID。</dd>
            
            <dt><code>createDate</code></dt>
            
            <dd>创建时间。参考
            <a href="#HFSPlusDates">HFS+ Dates</a> 。另外，Volume Header的
            <code>createDate</code> 不是GMT；而是当时时间。</dd>
            
            <dt><code>contentModDate</code></dt>
            
            <dd>修改时间。参考
            <a href="#HFSPlusDates">HFS+ Dates</a> </dd>
         </dl>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  The traditional Mac OS APIs use the
                  <code>contentModDate</code> when getting and
                  setting the modification date. The traditional Mac OS
                  APIs treat <code>attributeModDate</code> as a
                  <a href="#ReservedAndPadFields">保留</a> field.</p>
         </td></tr></tbody></table></center>
         
         <dl>
            <dt><code>attributeModDate</code></dt>
            
            <dd>此catalog record 的修改时间。已 <a href="#ReservedAndPadFields">保留</a>。
            In Mac OS X, the BSD APIs use this field as the folder's change time
            (returned in the <code>st_ctime</code> field of <code>struct stat</code>).
            All versions of Mac OS 8 and 9 treat this field as reserved. See
            <a href="#HFSPlusDates">HFS+ Dates</a> for a description of
            the format.</dd>
            
            <dt><code>accessDate</code></dt>
            
            <dd>访问时间。参考
            <a href="#HFSPlusDates">HFS+ Dates</a>。</dd>
         </dl>
         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  The traditional Mac OS implementation of HFS+ does not
                  maintain the <code>accessDate</code> field. Folders
                  created by traditional Mac OS have an
                  <code>accessDate</code> of zero.</p>
         </td></tr></tbody></table></center>
         
         <dl>
            <dt><code>backupDate</code></dt>
            
            <dd>备份时间，主要用于应用程序。参考 <a href="#HFSPlusDates">HFS+ Dates</a>
            。</dd>
            
            <dt><code>permissions</code></dt>
            
            <dd>权限，参考
            <a href="#HFSPlusPermissions">HFS+ Permissions</a>
            。</dd>
		</dl>
		         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  The traditional Mac OS implementation of HFS+ does not use
                  the <code>permissions</code> field. Folders created
                  by traditional Mac OS have the entire field set to 0.</p>
         </td></tr></tbody></table></center>
		<dl>
            <dt><code>userInfo</code></dt>
            
            <dd>用于Finder。并不是HFS+需要的，参考 <a href="#FinderInfo">
            Finder Info</a> 一节。</dd>
            
            <dt><code>finderInfo</code></dt>
            
            <dd>用于Finder，并不是HFS+需要的，参考<a href="#FinderInfo">
            Finder Info</a>  一节。</dd>
            
            <dt><code>textEncoding</code></dt>
            
            <dd>文本编码，参考<a href="#TextEncodings">Text Encodings</a>
            。</dd>
            
            <dt><code>reserved</code></dt>
            
            <dd>            <a href="#ReservedAndPadFields">保留</a>。</dd>
         </dl>
         
         <h4><a name="CatalogFileRecord"></a>Catalog File Records
         </h4>
         
         <p>catalog file record 用来储存文件的信息。
         数据结构为
         <code>HFSPlusCatalogFile</code> </p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct HFSPlusCatalogFile {
    SInt16              recordType;
    UInt16              flags;
    UInt32              reserved1;
    HFSCatalogNodeID    fileID;
    UInt32              createDate;
    UInt32              contentModDate;
    UInt32              attributeModDate;
    UInt32              accessDate;
    UInt32              backupDate;
    HFSPlusBSDInfo      permissions;
    FileInfo            userInfo;
    ExtendedFileInfo    finderInfo;
    UInt32              textEncoding;
    UInt32              reserved2;
&nbsp;
    HFSPlusForkData     dataFork;
    HFSPlusForkData     resourceFork;
};
typedef struct HFSPlusCatalogFile HFSPlusCatalogFile;
&nbsp;</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>结构中各个域的作用如下：</p>
         
         <dl>
            <dt><code>recordType</code></dt>
            
            <dd>总是 <code>kHFSPlusFileRecord</code>。</dd>
            
            <dt><code>flags</code></dt>
            
            <dd>This field contains bit flags about the file. The
            currently defined bits are <a href="#FileFlags">described
            below</a>。
            <a href="#ReservedAndPadFields">保留</a>.</dd>
            
            <dt><code>reserved1</code></dt>
            
            <dd>            <a href="#ReservedAndPadFields">保留</a>。</dd>
            
            <dt><code>fileID</code></dt>
            
            <dd>文件的 <a href="#CNID">CNID</a>。</dd>
            
            <dt><code>createDate</code></dt>
            
            <dd>The date and time the file was created. See
            <a href="#HFSPlusDates">HFS+ Dates</a> for a
            description of the format.</dd>
            
            <dt><code>contentModDate</code></dt>
            
            <dd>The date and time the file's contents were last
            changed by extending, truncating, or writing either of
            the forks. See <a href="#HFSPlusDates">HFS+ Dates</a>
            for a description of the format.</dd>
            
            <dt><code>attributeModDate</code></dt>
            
            <dd>The last date and time that any field in the
            file's catalog record was changed. An implementation may treat
            this field as <a href="#ReservedAndPadFields">保留</a>.
            In Mac OS X, the BSD APIs use this field as the file's change time
            (returned in the <code>st_ctime</code> field of <code>struct stat</code>).
            All versions of Mac OS 8 and 9 treat this field as reserved. See
            <a href="#HFSPlusDates">HFS+ Dates</a> for a description of
            the format.</dd>

            <dt><code>accessDate</code></dt>
            
            <dd>The date and time the file's contents were last read.
            This field has no analog in the HFS catalog record. It
            represents the last time either of a file's forks was
            read. This field exists to support POSIX semantics when
            the volume is mounted on Mac OS X and some non-Mac OS platforms. See
            <a href="#HFSPlusDates">HFS+ Dates</a> for a
            description of the format.</dd>
         </dl>
         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  The traditional Mac OS implementation of HFS+ does not
                  maintain the <code>accessDate</code> field. Files
                  created by traditional Mac OS have an
                  <code>accessDate</code> of zero.</p>
         </td></tr></tbody></table></center>
         
         <dl>
            <dt><code>backupDate</code></dt>
            
            <dd>The date and time the file was last backed up. The
            volume format requires no special action on this field;
            it simply defines the field for the benefit of user
            programs. See <a href="#HFSPlusDates">HFS+ Dates</a>
            for a description of the format.</dd>
            
            <dt><code>permissions</code></dt>
            
            <dd>This field contains file permissions, similar to
            those defined by POSIX. See
            <a href="#HFSPlusPermissions">HFS+ Permissions</a>
            for a description of the format.</dd>
         </dl>
         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  The traditional Mac OS implementation of HFS+ does not use
                  the <code>permissions</code> field. Files created
                  by traditional Mac OS have the entire field set to 0.</p>
         </td></tr></tbody></table></center>
         
         <dl>
            <dt><code>userInfo</code></dt>
            
            <dd>This field contains information used by the Mac OS
            Finder. For more information, see the <a href="#FinderInfo">
            Finder Info</a> section of this note.</dd>
            
            <dt><code>finderInfo</code></dt>
            
            <dd>This field contains information used by the Mac OS
            Finder. The contents of this structure are not strictly part of the HFS+
            specification, but general information is in the <a href="#FinderInfo">
            Finder Info</a> section of this note.</dd>
            
            <dt><code>textEncoding</code></dt>
            
            <dd>A hint as to text encoding from which the file name
            was derived. This hint can be used to improved the
            quality of the conversion of the name to a Mac OS encoded
            Pascal string. See <a href="#TextEncodings">Text
            Encodings</a> for details.</dd>
            
            <dt><code>reserved2</code></dt>
            
            <dd>            <a href="#ReservedAndPadFields">保留</a>。</dd>
            
            <dt><code>dataFork</code></dt>
            
            <dd>data fork。参考 <a href="tn1150.html">Fork Data
            Structure</a> 的
            <code>HFSPlusForkData</code> 类型。</dd>
            
            <dt><code>resourceFork</code></dt>
            
            <dd>resource fork。 参考 <a href="tn1150.html">Fork Data
            Structure</a> 的
            <code>HFSPlusForkData</code> 类型。</dd>
         </dl>
         
         <p>每个fork的前8个extents描述保存在 <code>HFSPlusForkData</code> 。
         如果还有剩余，其它保存在 <a href="#ExtentsOverflowFile">extents
         overflow file</a>。</p>
         
         <p><a name="FileFlags"></a>The following constants define
         bit flags in the file record's <code>flags</code> field:
         </p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>enum {
    kHFSFileLockedBit       = 0x0000,
    kHFSFileLockedMask      = 0x0001,
    kHFSThreadExistsBit     = 0x0001,
    kHFSThreadExistsMask    = 0x0002
};</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>The values have the following meaning:</p>
         
         <dl>
            <dt><code>kHFSFileLockedBit</code>,
            <code>kHFSFileLockedMask</code></dt>
            
            <dd>If <code>kHFSFileLockedBit</code> is set, then none
            of the forks may be extended, truncated, or written to.
            They may only be opened for reading (not for writing).
            The catalog information (like <code>finderInfo</code> and
            <code>userInfo</code>) may still be changed.</dd>
            
            <dt><code>kHFSThreadExistsBit</code>,
            <code>kHFSThreadExistsMask</code></dt>
            
            <dd>This bit incidates that the file has a thread record.
            As all files in HFS+ have thread records, this bit
            must be set.</dd>
         </dl>
         
         <h4><a name="CatalogThreadRecord"></a>Catalog Thread Records
         </h4>
         
         <p>thread record用来连接到文件或目录使用的<a href="#CNID">CNID</a>
         。它的结构是
         <code>HFSPlusCatalogThread</code> </p>
         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  HFS, 只有folders必须要thread records，而文件是可选的。在HFS+，文件和目录都需要。</p>
         </td></tr></tbody></table></center>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct HFSPlusCatalogThread {
    SInt16              recordType;
    SInt16              reserved;
    HFSCatalogNodeID    parentID;
    HFSUniStr255        nodeName;
};
typedef struct HFSPlusCatalogThread HFSPlusCatalogThread;</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>结构中各个域的作用如下：</p>
         
         <dl>
            <dt><code>recordType</code></dt>
            
            <dd>总是 <code>kHFSPlusFileRecord</code> 或
            <code>kHFSPlusFolderRecord</code>，取决一于它
            是指向的内容。两种情况下record包含的结构相同。</dd>
            
            <dt><code>reserved1</code></dt>
            
            <dd><a href="#ReservedAndPadFields">保留</a>。</dd>
            
            <dt><code>parentID</code></dt>
            
            <dd>由这个thread引用的目录或文件的父目录 <a href="#CNID">CNID</a>。</dd>
            
            <dt><code>nodeName</code></dt>
            
            <dd>由这个thread引用的目录或文件的名字</dd>
         </dl>
         
         <p>下一节将描述如何通过<a href="#CNID">CNID</a>找到到对方伯文件或目录。</p>
         
         <h3><a name="CatalogTreeUsage"></a>Catalog Tree Usage</h3>
         
         <p>文件和目录的records通常都有一个非空的 <code>nodeName</code>。
          同一个目录下的文件，它们都是连接存放在catalog中，因为它们key
          中的 <code>parentID</code> 相同，仅<code>nodeName</code>有区别</p>
         
         <p>The key for a thread record is the file's or folder's <a href="#CNID">CNID</a> (not the CNID of the parent folder) and
         an empty (zero length) <code>nodeName</code>. This allows a
         file or folder to by found using just the CNID. The thread
         record contains the <code>parentID</code> and
         <code>nodeName</code> field of the file or folder itself.</p>
         
         <p>通过一个CNID找到文件或目录需要二步。每一步是通过CNID找到文件或目录的
         thread record。通过它可以知道文件或目录的父目录ID和名字。下一步就通过它们找到
         真实的文件和目录record。</p>
         
         <p>因为文件不能再包含文件或目录，所以没有catalog records的key的<code>parentID</code>
         等于一个文件的 CNID 且 <code>nodeName</code> 不等于0. These unused key values are reserved.</p>

		<h3><a name="FinderInfo"></a>Finder Info</h3>
		
		<p>参考 <a href="http://developer.apple.com/documentation/Carbon/Reference/Finder_Interface/index.html">
		Finder Interface Reference</a> 以获取Finder是如何使用它的。</p>

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct Point {
  SInt16              v;
  SInt16              h;
};
typedef struct Point  Point;

struct Rect {
  SInt16              top;
  SInt16              left;
  SInt16              bottom;
  SInt16              right;
};
typedef struct Rect   Rect;

/* OSType is a 32-bit value made by packing four 1-byte characters 
   together. */
typedef UInt32        FourCharCode;
typedef FourCharCode  OSType;

/* Finder flags (finderFlags, fdFlags and frFlags) */
enum {
  kIsOnDesk       = 0x0001,     /* Files and folders (System 6) */
  kColor          = 0x000E,     /* Files and folders */
  kIsShared       = 0x0040,     /* Files only (Applications only) If */
                                /* clear, the application needs */
                                /* to write to its resource fork, */
                                /* and therefore cannot be shared */
                                /* on a server */
  kHasNoINITs     = 0x0080,     /* Files only (Extensions/Control */
                                /* Panels only) */
                                /* This file contains no INIT resource */
  kHasBeenInited  = 0x0100,     /* Files only.  Clear if the file */
                                /* contains desktop database resources */
                                /* ('BNDL', 'FREF', 'open', 'kind'...) */
                                /* that have not been added yet.  Set */
                                /* only by the Finder. */
                                /* Reserved for folders */
  kHasCustomIcon  = 0x0400,     /* Files and folders */
  kIsStationery   = 0x0800,     /* Files only */
  kNameLocked     = 0x1000,     /* Files and folders */
  kHasBundle      = 0x2000,     /* Files only */
  kIsInvisible    = 0x4000,     /* Files and folders */
  kIsAlias        = 0x8000      /* Files only */
};

/* Extended flags (extendedFinderFlags, fdXFlags and frXFlags) */
enum {
  kExtendedFlagsAreInvalid    = 0x8000, /* The other extended flags */
                                        /* should be ignored */
  kExtendedFlagHasCustomBadge = 0x0100, /* The file or folder has a */
                                        /* badge resource */
  kExtendedFlagHasRoutingInfo = 0x0004  /* The file contains routing */
                                        /* info resource */
};

struct FileInfo {
  OSType    fileType;           /* The type of the file */
  OSType    fileCreator;        /* The file's creator */
  UInt16    finderFlags;
  Point     location;           /* File's location in the folder. */
  UInt16    reservedField;
};
typedef struct FileInfo   FileInfo;

struct ExtendedFileInfo {
  SInt16    reserved1[4];
  UInt16    extendedFinderFlags;
  SInt16    reserved2;
  SInt32    putAwayFolderID;
};
typedef struct ExtendedFileInfo   ExtendedFileInfo;

struct FolderInfo {
  Rect      windowBounds;       /* The position and dimension of the */
                                /* folder's window */
  UInt16    finderFlags;
  Point     location;           /* Folder's location in the parent */
                                /* folder. If set to {0, 0}, the Finder */
                                /* will place the item automatically */
  UInt16    reservedField;
};
typedef struct FolderInfo   FolderInfo;

struct ExtendedFolderInfo {
  Point     scrollPosition;     /* Scroll position (for icon views) */
  SInt32    reserved1;
  UInt16    extendedFinderFlags;
  SInt16    reserved2;
  SInt32    putAwayFolderID;
};
typedef struct ExtendedFolderInfo   ExtendedFolderInfo;</pre>
    </td>
</tr>
</tbody></table></center>

<p><a href="#top">返回顶部</a></p>

         <h2><a name="ExtentsOverflowFile"></a>Extents Overflow File</h2>
         
         <p>HFS+ 记录文件的分配情况在一个extents链表中。每个extent由一对数字组成：
         第一个block number和allocation blocks number。文件record中只包含了前8个
         extents，其它的则存放在extents overflow file。</p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  <a href="tn1150.html">Fork Data
                  Structure</a> discusses how HFS+ maintains
                  information about a fork.</p>
         </td></tr></tbody></table></center>
         
         <p>extents overflow file 也是
         <a href="#BTrees">B-tree</a>。结构与catalog file相似。
         extents overflow file的key简单且key length固定，只有一种
         类型的data record。</p>
         
         <h3>Extents Overflow File Key</h3>
         
         <p>extents overflow file 的key的结构是<code>HFSPlusExtentKey</code>。</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct HFSPlusExtentKey {
    UInt16              keyLength;
    UInt8               forkType;
    UInt8               pad;
    HFSCatalogNodeID    fileID;
    UInt32              startBlock;
};
typedef struct HFSPlusExtentKey HFSPlusExtentKey;</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>结构中各个域的作用如下：</p>
         
         <dl>
            <dt><code>keyLength</code></dt>
            
            <dd>所有B-tree的<a href="#KeyedRecords">keyed records</a>
            都需要 <code>keyLength</code>。</dd>
            
            <dt><code>forkType</code></dt>
            
            <dd>fork中数据的类型。0为data fork，0xFF为resource fork。</dd>
            
            <dt><code>pad</code></dt>
            
            <dd>
            <a href="#ReservedAndPadFields">pad</a> </dd>
            
            <dt><code>fileID</code></dt>
            
            <dd>文件的<a href="#CNID">CNID</a> </dd>
            
            <dt><code>startBlock</code></dt>
            
            <dd>在allocation blocks，即文件中的逻辑起始Block。因为extent block也可能
            有多个，这样以方便寻址。</dd>
         </dl>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  Typically, an implementation will keep a copy of
                  the initial extents from the catalog record. When
                  trying to access part of the fork, they see whether
                  that position is beyond the extents described in
                  the catalog record; if so, they use that offset (in
                  allocation blocks) to find the appropriate extents
                  B-tree record. See
                  <a href="#ExtentsOverflowFileUsage"> Extents
                  Overflow File Usage for more information.</a></p>
         </td></tr></tbody></table></center>
         
         <p>Two <code>HFSPlusExtentKey</code> structures are compared
         by comparing their fields in the following order:
         <code>fileID</code>, <code>forkType</code>,
         <code>startBlock</code>. Thus, all the extent records for a
         particular fork are grouped together in the B-tree, right
         next to all the extent records for the other fork of the
         file.</p>
         
         <h3>Extents Overflow File Data</h3>
         
         <p>The data records for an extents overflow file (the
         <b>extent records</b>) are described by the
         <code>HFSPlusExtentRecord</code> type, which is described in
         detail in <a href="tn1150.html">Fork Data
         Structure</a>.</p>
         
        <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  Remember that the <code>HFSPlusExtentRecord</code>
                  contains descriptors for eight extents. The first
                  eight extents in a fork are held in its
                  <a href="#CatalogFileRecord">catalog file
                  record</a>. So the number of extent records for a
                  fork is ((number of extents - 8 + 7) / 8).</p>
                  </td></tr></tbody></table></center>
                  
         
         <h3><a name="ExtentsOverflowFileUsage"></a>Extents Overflow
         File Usage</h3>
         
         <p>The most important thing to remember about extents
         overflow file is that it is only used for forks with more
         than eight extents. In most cases, forks have fewer extents,
         and all the extents information for the fork is held in its
         catalog file record. However, for more fragmented forks, the
         extra extents information is stored in the extents overflow
         file.</p>
         
         <p>When an implementation needs to map a fork offset into a
         position on disk, it first looks through the extent records in
         the catalog file record. If the fork offset is within one
         these extents, the implementation can find the corresponding
         position without consulting the extents overflow file.</p>
         
         <p>If, on the other hand, the fork offset is beyond the last
         extent recorded in the catalog file record, the
         implementation must look in the next extent record, which is
         stored in the extents overflow file. To find this record,
         the implementation must form a key, which consists of
         information about the fork (the fork type and the file ID)
         and the offset info the fork (the start block).</p>
         
         <p>Because extent records are partially keyed off the fork
         offset of the first extent in the record, the implementation
         must have all the preceding extent records in order to know
         the fork offset to form the key of the next extent record.
         For example, if the fork has two extent records in the
         extents overflow file, the implementation must read the
         first extent record to calculate the fork offset for the key
         for the second extent record.</p>
         
         <p>However, you can use the <code>startBlock</code> in the
         extent key to go directly to the record you need. Here's a
         complicated example:</p>
         
         <p>We've got a fork with a total of 23 extents (very
         fragmented!). The <code>blockCounts</code> for the extents,
         in order, are as follows: one extent of 6 allocation blocks,
         14 extents of one allocation block each, two extents of two
         allocation blocks each, one extent of 7 allocation blocks,
         and five more extents of one allocation block each. The fork
         contains a total of 36 allocation blocks.</p>
         
         <p>The block counts for the catalog's fork data are: 6, 1,
         1, 1, 1, 1, 1, 1. There is an extent overflow record whose
         startBlock is 13 (0+6+1+1+1+1+1+1+1), and has the following
         block counts: 1, 1, 1, 1, 1, 1, 1, 2. There is a second
         extent overflow record whose <code>startBlock</code> is 22
         (13+1+1+1+1+1+1+1+2), and has the following block counts: 2,
         7, 1, 1, 1, 1, 1, 0. Note this last record only contains
         seven extents.</p>
         
         <p>Suppose the allocation block size for the volume is 4K.
         Suppose we want to start reading from the file at an offset
         of 108K. We want to know where the data is on the volume,
         and how much contiguous data is there.</p>
         
         <p>First, we divide 108K (the fork offset) by 4K (the
         allocation block size) to get 27, which is the number of
         allocation blocks from the start of the fork. So, we want to
         know where fork allocation block #27 is. We notice that 27
         is greater than or equal to 13 (the number of allocation
         blocks in the catalog's fork data), so we're going to have
         to look in the extents B-tree.</p>
         
         <p>We construct a search key with the appropriate
         <code>fileID</code> and <code>forkType</code>, and set
         <code>startBlock</code> to 27 (the desired fork allocation
         block number). We then search the extents B-tree for the
         record whose key is less than or equal to our search key. We
         find the second extent overflow record (the one with
         <code>startBlock</code>=22). It has the same
         <code>fileID</code> and <code>forkType</code>, so things are
         good. Now we just need to figure out which extent within
         that record to use.</p>
         
         <p>We compute 27 (the desired fork allocation block) minus
         22 (the <code>startBlock</code>) and get 5. So, we want the
         extent that is 5 allocation blocks "into" the record. We try
         the first extent. It's only two allocation blocks long, so
         the desired extent is 3 allocation blocks after that first
         extent in the record. The next extent is 7 allocation blocks
         long. Since 7 is greater than 3, we know the desired fork
         position is within this extent (the second extent in the
         second overflow record). Further, we know that there are
         7-3=4 contiguous allocation blocks (i.e., 16K).</p>
         
         <p>We grab the <code>startBlock</code> for that second
         extent (i.e., the one whose <code>blockCount</code> is 7);
         suppose this number is 444. We add 3 (since the desired
         position was 3 allocation blocks into the extent we found).
         So, the desired position is in allocation block 444+3=447 on
         the volume. That is 447*4K=1788K from the start of the HFS+ volume. (Since the Volume Header always starts 1K after
         the start of the HFS+ volume, the desired fork position
         is 1787K after the start of the Volume Header.)</p>
         
         <h3><a name="BadBlockFile"></a>Bad Block File</h3>
         
         <p>The extent overflow file is also used to hold information
         about the bad block file. The bad block file is used to mark
         areas on the disk as bad, unable to be used for storing
         data. This is typically used to map out bad sectors on the
         disk.</p>
         

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  All space on an HFS+ volume is allocated in
                  terms of allocation blocks. Typically, allocation
                  blocks are larger than sectors. If a sector is
                  found to be bad, the entire allocation block is
                  unusable.</p>
         </td></tr></tbody></table></center>
         
         <p>When an HFS+ volume is embedded within an HFS wrapper
         (the way Mac OS normally initializes a hard disk), the space
         used by the HFS+ volume is marked as part of the bad
         block file <em>within the HFS wrapper itself</em>. (This
         sounds confusing because you have a volume within another
         volume.)</p>
         
         <p>The bad block file is not a file in the same sense as a
         user file (it doesn't have a file record in the catalog) or
         one of the special files (it's not referenced by the volume
         header). Instead, the bad block file uses a special
         <a href="#CNID">CNID</a>
         (<code>kHFSBadBlockFileID</code>) as the key for extent
         records in the extents overflow file. When a block is marked
         as bad, an extent with this CNID and encompassing the bad
         block is added to the extents overflow file. The block is
         marked as used in the <a href="#AllocationFile">allocation
         file</a>. These steps prevent the block from being used for
         data by the file system.</p>
         

                  <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  The bad block file is necessary because marking a
                  bad block as used in the allocation file is
                  insufficient. One
                  <a href="#AllocationFileConsistencyCheck">common
                  consistency check</a> for HFS+ volumes is to
                  verify that all the allocation blocks on the volume
                  are being used by real data. If such a check were
                  run on a volume with bad blocks that weren't also
                  covered by extents in the bad block file, the bad
                  blocks would be freed and might be reused for file
                  system data.</p>
                  </td></tr></tbody></table></center>
         
         <p>Bad block extent records are always assumed to reference
         the data fork. The <code>forkType</code> field of the key
         must be 0.</p>
         

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  Because an extent record holds up to eight extents,
                  adding a bad block extent to the bad block file
                  does not necessarily require the addition of a new
                  extent record.</p>
                  </td></tr></tbody></table></center>
                  
         <p>HFS uses a similar mechanism to store information about
         bad blocks. This facility is used by the
         <a href="#HFSWrapper">HFS Wrapper</a> to hold an entire HFS+ volume as bad blocks on an HFS disk.</p>

<p><a href="#top">返回顶部</a></p>


         <h2><a name="AllocationFile"></a>Allocation File</h2>
         
         <p>HFS+ uses an allocation file to keep track of whether
         each allocation block in a volume is currently allocated to
         some file system structure or not. The contents of the
         allocation file is a bitmap. The bitmap contains one bit for
         each allocation block in the volume. If a bit is set, the
         corresponding allocation block is currently in use by some
         file system structure. If a bit is clear, the corresponding
         allocation block is not currently in use, and is available
         for allocation.</p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  HFS stores allocation information in a special area
                  on the volume, known as the <b>volume bitmap</b>.
                  The allocation file mechanism used by HFS+ has
                  a number of advantages.</p>
                  
                  <ul>
                     <li>Using a file allows the bitmap itself to be
                     allocated from allocation blocks. This
                     simplifies the design, since volumes are now
                     comprised of only one type of block -- the
                     allocation block. The HFS is slightly more
                     complex because it uses 512-byte blocks to hold the
                     allocation bitmap and allocation blocks to hold
                     file data.</li>
                     
                     <li>The allocation file does not have to be
                     contiguous, which allows allocation information
                     and user data to be interleaved. Many modern
                     file systems do this to reduce head travel when
                     growing files.</li>
                     
                     <li>The allocation file can be extended, which
                     makes it significantly easier to increase the
                     number of allocation blocks on a disk. This is
                     useful if you want to either decrease the
                     allocation block size on a disk, or increase the
                     total disk size.</li>
                     
                     <li>The allocation file may be shrunk. This
                     makes it easy to create a disk images suitable
                     for volumes of varying sizes. The allocation
                     file in the disk image is sized to hold enough
                     allocation data for the largest disk, and shrunk
                     back when the disk is written to a smaller disk.</li>
                  </ul>
  </td></tr></tbody></table></center>            
         
         <p>Each byte in the allocation file holds the state of eight
         allocation blocks. The byte at offset X into the file
         contains the allocation state of allocations blocks (X * 8)
         through (X * 8 + 7). Within each byte, the most significant
         bit holds information about the allocation block with the
         lowest number, the least significant bit holds information
         about the allocation block with the highest number. Listing
         1 shows how you would test whether an allocation block is in
         use, assuming that you've read the entire allocation file
         into memory.</p>
         
        

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>static Boolean IsAllocationBlockUsed(UInt32 thisAllocationBlock,
                                     UInt8 *allocationFileContents)
{
    UInt8 thisByte;

    thisByte = allocationFileContents[thisAllocationBlock / 8];
    return (thisByte &amp; (1 &lt;&lt; (7 - (thisAllocationBlock % 8)))) != 0;
}</pre>
    </td>
</tr>
<tr>
<td><p><b>Listing 1</b> Determining whether an
         allocation block is in use.</p>
         </td></tr>
</tbody></table></center> 


         
         
         <p>The size of the allocation file depends on the number of
         allocation blocks in the volume, which in turn depends both
         on the size of the disk and on the size of the
         volume's allocation blocks. For example, a volume on a 1 GB disk and
         having an allocation block size of 4 KB needs an allocation
         file size of 256 Kbits (32 KB, or 8 allocation blocks).
         Since the allocation file itself is allocated using
         allocation blocks, it always occupies an integral number of
         allocation blocks (its size may be rounded up).</p>
         
         <p>The allocation file may be larger than the minimum number
         of bits required for the given volume size. Any unused bits
         in the bitmap must be set to zero.</p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
                  Since the number of allocation blocks is determined
                  by a 32-bit number, the size of the allocation file
                  can be up to 512 MB in size, a radical increase
                  over HFS's 8 KB limit.</p>
  </td></tr></tbody></table></center>       
  
                  <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  Because the entire volume is composed of allocation
                  blocks (with the possible
                  exception of the alternate volume header, as
                  described <a href="#OddSizeVolumes">above</a>), the volume header,
                  alternate volume header, and reserved areas (the
                  first 1024 bytes and the last 512 bytes) must be
                  marked as allocated in the allocation file. The
                  actual number of allocation blocks allocated for
                  these areas varies with the size of the
                  allocation blocks. Any allocation block that
                  contains any of these areas must be marked
                  allocated.</p>
                  
                  <p>For example, if 512-byte allocation blocks are
                  used, the first three and last two allocation
                  blocks are allocated. With 1024-byte allocation
                  blocks, the first two and the last allocation
                  blocks are allocated. For larger allocation block
                  sizes, only the first and last allocation blocks
                  are allocated for these areas.</p>
                  
                  <p>See the <a href="#VolumeHeader">Volume
                  Header</a> section for a description of these
                  areas.</p>
      </td></tr></tbody></table></center>

<p><a href="#top">返回顶部</a></p>


         <h2><a name="AttributesFile"></a>Attributes File</h2>
         
         <p>HFS+的attributes File保留用于将来使用的命名forks（类型NTFS中的流）。
         attributes file 同样是
         <a href="#BTrees">B-tree</a> 文件。并通过volume header的<code>HFSPlusForkData</code>访问。
         attributes files 由一个变长key和3个record types组成，比
         catalog file 要复杂。</p>
         
         <p>卷可能没有 attributes file。取决于
         volume header 的 attributes file 的第一个extent。如果为0，则不存在。</p>
         
         <p> B-Trees 一节定义了一套
         <a href="#NodeSizes">node size</a>的规则，attributes file也适用。
         另外，
         attributes file 的node size至少是4 KB。
         (<code>kHFSPlusAttrMinNodeSize</code>)</p>
         

                  <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  目前没有定义如何如组织里面的数据。特别是：</p>
                  
                  <ul>
                     <li>the structure of the keys in the attribute
                     B-tree has not been finalized and is subject to
                     change, and</li>
                     
                     <li>addition attribute's file data record types
                     may be defined.</li>
                  </ul>
                  
                  <p>An implementation written to this specification
                  may use the details that are final to perform basic
                  consistency checks on attributes. These checks will
                  be compatible with future implementations written
                  to a final attributes specification. See
                  <a href="#AttributesAllocationFileConsistency">Attributes
                  and the Allocation File Consistency Check</a>.</p>
              </td></tr></tbody></table></center>
              
         
         <h3>Attributes File Data</h3>
         

                  <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  Several types of attributes file data records are
                  defined. It is possible that additional record
                  types will be defined in future specifications.
                  Implementations written to this specification must
                  ignore record types not defined here.</p>
              </td></tr></tbody></table></center>
         
         <p>attributes file的叶节点包含了data
         records, 即 <b>attributes</b>。共有2种attribute：</p>
         
         <ol>
            <li><b>Fork data attributes</b> 用于大型的attributes。
            因为这些 attribute's data 储存在卷里的其它地方。</li>
            
            <li><b>Extension attributes</b>，用于可扩展的 fork data
            attributes，允许fork data attribute 超过8个extents.</li>
         </ol>
         
         <p>每个 record 都是以 <code>recordType</code> 开始的，
         <code>recordType</code> 包含下面一些值。</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>enum {
    kHFSPlusAttrInlineData  = 0x10,
    kHFSPlusAttrForkData    = 0x20,
    kHFSPlusAttrExtents     = 0x30
};</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>各值意义如下:</p>
         
         <dl>
            <dt><code>kHFSPlusAttrInlineData</code></dt>
            
            <dd>保留将来使用。</dd>
            
            <dt><code>kHFSPlusAttrForkData</code></dt>
            
            <dd>这个record是<a href="#ForkDataAttributes">fork
            data attribute</a>。对应的结构是
            <code>HFSPlusAttrForkData</code>。</dd>
            
            <dt><code>kHFSPlusAttrExtents</code></dt>
            
            <dd>这个record是
            <a href="#ExtensionAttributes">extension attribute</a>
            。对应的结构是 <code>HFSPlusAttrExtents</code> 。
            <code>kHFSPlusAttrExtents</code> 是 
            <code>kHFSPlusAttrForkData</code> 的扩展版本。</dd>
         </dl>
         
         <p>下两2节将会描述fork data 和 extension attributes 的细节。</p>
         
         <h4><a name="ForkDataAttributes"></a>Fork Data Attributes
         </h4>
         
         <p>A fork data attribute is defined by the
         <code>HFSPlusAttrForkData</code> data type.</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct HFSPlusAttrForkData {
    UInt32          recordType;
    UInt32          reserved;
    HFSPlusForkData theFork;
};
typedef struct HFSPlusAttrForkData HFSPlusAttrForkData;</pre>
    </td>
</tr>
</tbody></table></center>
         
         <p>结构中各个域的作用如下：</p>
         
         <dl>
            <dt><code>recordType</code></dt>
            
            <dd>The attribute data record type. For fork data
            attributes, this is always
            <code>kHFSPlusAttrForkData</code>.</dd>
            
            <dt><code>reserved</code></dt>
            
            <dd>            <a href="#ReservedAndPadFields">保留</a>。</dd>
            
            <dt><code>theFork</code></dt>
            
            <dd>Information about the location and size of the
            attribute data. See <a href="tn1150.html">Fork
            Data Structure</a> for a description of the
            <code>HFSPlusForkData</code> type.</dd>
         </dl>
         
         <h4><a name="ExtensionAttributes"></a>Extension Attributes
         </h4>
         
         <p>A extension attribute is defined by the
         <code>HFSPlusAttrExtents</code> data type.</p>
         

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct HFSPlusAttrExtents {
    UInt32                  recordType;
    UInt32                  reserved;
    HFSPlusExtentRecord     extents;
};
typedef struct HFSPlusAttrExtents HFSPlusAttrExtents;</pre>
    </td>
</tr>
</tbody></table></center>
              
         
         <p>结构中各个域的作用如下：</p>
         
         <dl>
            <dt><code>recordType</code></dt>
            
            <dd>对于 extension attributes, 总是<code>kHFSPlusAttrExtents</code>。</dd> 
            <dt><code>reserved</code></dt>
            
            <dd><a href="#ReservedAndPadFields">保留</a>。</dd>
            
            <dt><code>extents</code></dt>
            
            <dd>8个保存属性内容的extents。</dd>
         </dl>
         
         <h3><a name="AttributesAllocationFileConsistency"></a>Attributes
         与Allocation File一致性检查</h3>
         
         <p>当attributes　file的key结构没有指定时，仍然存在一种方法
         使用attribute　file信息，通过allocation file一致性检查。
         叶records的的dataFork是已知的，因此，遍历所有分配的block就能知道
         那些被fork data attributes占用了。</p>
         
         <p>参考 <a href="#AllocationFileConsistencyCheck">Allocation
         File　一致性检查</a> 更多细节</p><br>

<p><a href="#top">返回顶部</a></p>


         <h2><a name="StartupFile"></a>Startup File</h2>
         
         <p>The startup file is a special file intended to hold
         information needed when booting a system that does not have
         built-in (ROM) support for HFS+. A boot loader can find
         the startup file without full knowledge of the HFS+
         volume format (B-trees, catalog file, and so on). Instead,
         the <a href="#VolumeHeader">volume header</a> contains the
         location of the first eight extents of the startup file.</p>


         <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
         
         It is legal for the startup file to contain more than eight
         extents, and for the remaining extents to be placed in the
         extents overflow file. However, doing so defeats the purpose
         of the startup file.</p>
         </td></tr></tbody></table></center>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>         
         Mac OS does not use the startup file to boot from HFS+
         disks. Instead, it uses the HFS wrapper, as
         <a href="#HFSWrapper">described later in this document</a>.</p>
</td></tr></tbody></table></center>


<p><a href="#top">返回顶部</a></p>


         <h2><a name="HardLinks"></a>Hard Links</h2>
         
         <p><b>Hard links</b> are a feature that allows multiple directory entries
         to refer to a single file's content.  They are a way to give a single
         file multiple names, possibly in multiple directories.  This section
         describes how Mac OS X implements hard links on HFS+ volumes.</p>
         
         <p>The Mac OS X implementation of hard links on HFS+ volumes
         was done using the existing metadata fields of the catalog records.
         This makes it possible to back up and restore a volume using hard
         links, by backing up and restoring individual files, without having
         to understand or interpret the hard links.  An HFS+ implementation
         may choose to automatically follow hard links, or not.</p>
         
         <p>Hard links in HFS+ are represented by a set of several files.
         The actual file content (which is shared by each of the hard links)
         is stored in a special <b>indirect node file</b>.  This indirect node file
         is the equivalent of an inode in a traditional UNIX file system.</p>
         
         <p>HFS+ uses special <b>hard link files</b> (or <b>links</b>)
         to refer (or point) to an indirect node file.  There is one hard link
         file for each directory entry or name that refers to the file content.</p>
         
         <p>Indirect node files exist in a special directory called the
         <b>metadata directory</b>.  This directory exists in the volume's root
         directory.  The name of the metadata directory is four null
         characters followed by the string "HFS+ Private Data".  The
         directory's creation date is set to the creation date of the
         volume's root directory. The <code>kIsInvisible</code> and
         <code>kNameLocked</code> bits are set in the directory's
         <a href="#FinderInfo">Finder information</a>.  The icon
         <code>location</code> in the Finder info is set to the point
         (22460, 22460). These Finder info settings are not mandatory,
         but they tend to reduce accidental changes to the metadata directory.
         An implementation that automatically follows hard links should
         make the metadata directory inaccessable from its normal
         file system interface.</p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>         
         The <a href="#StringComparisonAlgorithm">case-insensitive Unicode
         string comparison</a> used by HFS+ and case-insensitive
         <a href="#HFSX">HFSX</a> sorts null characters after all other
         characters, so the metadata directory will typically be the last
         item in the root directory.  On case-sensitive <a href="#HFSX">HFSX</a>
         volumes, null characters sort before other characters, so the
         metadata directory will typically be the first item in the root directory.</p>
</td></tr></tbody></table></center>

         <p>Indirect node files have a special identifying number called a
         <b>link reference</b>.  The link reference is unique among indirect
         node files on a given volume.  The link reference is not related to
         <a href="#CNID">catalog node IDs</a>.  When a new indirect node
         file is created, it is assigned a new link reference randomly chosen
         from the range 100 to 1073741923.</p>
         
         <p>The file name of an indirect node file is the string "iNode"
         immediately followed by the link reference converted to decimal text,
         with no leading zeroes.  For example, an indirect node file with link
         reference 123 would have the name "iNode123".</p>
         
         <p>An indirect node file <b>must</b> be a file, not a directory.
         Hard links to directories are not allowed because they could cause cycles
         in the directory hierarchy if a hard link pointed to one of its ancestor
         directories.</p>

		<p>The <code>linkCount</code> field in the
		<a href="#HFSPlusPermissions">permissions</a> is an estimate of
		the number of links referring to this indirect node file.  An
		implementation that understands hard links should increment this
		value when creating an additional link, and decrement the value
		when removing a link. However, some implementations (such as
		traditional Mac OS) do not understand hard links and may make
		changes that cause the <code>linkCount</code> to be inaccurate.
		Similarly, it is possible for a link to refer to an indirect
		node file that does not exist.  When removing a link, an
		implementation should not allow the <code>linkCount</code>
		to underflow; if it is already zero, do not change it.</p>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>         
         The inode number returned by the POSIX <code>stat</code>
         or <code>lstat</code> routines in the <code>st_ino</code>
         field of the <code>stat</code> structure is actually the
         <a href="#CNID">catalog node ID</a> of the indirect
         node file, not the link reference mentioned above.</p>

         <p>The reason for using a separate link reference number, instead of a
         <a href="#CNID">catalog node ID</a>, is to allow hard links to be
         backed up and restored by utilities that are not specifically aware
         of hard links.  As long as they preserve filenames, Finder info,
         and <a href="#HFSPlusPermissions">permissions</a>, then
         the hard links will be preserved.</p>
</td></tr></tbody></table></center>

         <p>Hard link files are ordinary files in the catalog.  The
         <a href="#CNID">catalog node ID</a> of a hard link
         file is different from the <a href="#CNID">catalog node ID</a>
         of the indirect node file it refers to, and different from the
         <a href="#CNID">catalog node ID</a> of any other hard link file.</p>
         
         <p>The <code>fileType</code> and <code>fileCreator</code> fields
         of the <code>userInfo</code> in the <a href="#CatalogFileRecord">
         catalog record</a> of a hard link file must be set to
         <code>kHardLinkFileType</code> and <code>kHFSPlusCreator</code>,
         respectively.  The hard link file's creation date should be set to 
         the creation date of the metadata directory. The hard link file's
         creation date may also be set to the creation date of the volume's
         root directory (if it differs from the creation date of the metadata
         directory), though this is deprecated. The <code>iNodeNum</code> field
         in the <a href="#HFSPlusPermissions">permissions</a> is set to the
         link reference of the indirect node file that the link refers to.
         For better compatibility with older versions of the Mac OS Finder,
         the <code>kHasBeenInited</code> flag should be set in the Finder
         flags. The other Finder information, and other dates in the catalog
         record are <a href="#ReservedAndPadFields">保留</a>.</p>

<center><table border="0" cellpadding="5" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<pre>enum {
    kHardLinkFileType = 0x686C6E6B,  /* 'hlnk' */
    kHFSPlusCreator   = 0x6866732B   /* 'hfs+' */
};</pre></td></tr>
</tbody></table></center>

         <p><a name="UnlinkedFiles"></a>POSIX semantics allow an open file to
         be unlinked (deleted).  These open but unlinked files are stored on HFS+ volumes much like a hard link.  When the open file is deleted, it
         is renamed and moved into the metadata directory.  The new name is the
         string "temp" followed by the <a href="#CNID">catalog node ID</a>
         converted to decimal text. When the file is eventually closed, this
         temporary file may be removed.  All such temporary files may be removed
         when repairing an unmounted HFS+ volume.</p>
         
         <h3>Repairing the Metadata Directory</h3>
         <p>When repairing an HFS+ volume with hard links or a metadata
         directory, there are several conditions that might need to be repaired:</p>
         <ul>
         	<li>Opened but deleted files (which are now orphaned).</li>
         	<li>Orphaned indirect node files (no hard links refer to them).</li>
         	<li>Broken hard link (hard link exists, but indirect node file does not).</li>
         	<li>Incorrect link count.</li>
         	<li>Link reference was 0.</li>
         </ul>
         
         <p>Opened but deleted files are files whose names start with "temp",
         and are in the metadata directory.  If the volume is not in use
         (not mounted, and not being used by any other utility), then these
         files can be deleted.  Volumes with a <a href="#Journal">journal</a>,
         even one with no active transactions, may have opened but undeleted
         files that need to be deleted.</p>
         
         <p>Detecting an orphaned indirect node file, broken hard link, or incorrect link
         count requires finding all hard link files in the catalog, and comparing
         the number of found hard links for each link reference with the link
         count of the corresponding indirect node file.</p>
         
         <p>A hard link with a link reference equal to 0 is invalid. Such a hard
         link may be the result of a hard link being copied or restored by an
         implementation or utility that does not use the <a href="#HFSPlusPermissions">
         permissions</a> in catalog records.  It may be possible to repair the
         hard link by determining the proper link reference.  Otherwise, the
         hard link should be deleted.</p>

<p><a href="#top">返回顶部</a></p>
         
         <h2><a name="Symlinks"></a>Symbolic Links</h2>
         
         <p>Similar to a hard link, a <b>symbolic link</b> is
         a special kind of file that refers to another file or directory.
         A symbolic link stores the path name of the file or directory it
         refers to.</p>
         
         <p>On an HFS+ volume, a symbolic link is stored
         as an ordinary file with special values in some of the fields of its
         <a href="#CatalogFileRecord">catalog record</a>.  The pathname of the
         file being referred to is stored in the data fork. The file type in
         the <code>fileMode</code> field of the <a href="#HFSPlusPermissions">
         permissions</a> is set to <code>S_IFLNK</code>. For compatibility
         with Carbon and Classic applications, the file type of a symbolic
         link is set to <code>kSymLinkFileType</code>, and the creator code
         is set to <code>kSymLinkCreator</code>.  The resource fork of the
         symbolic link has zero length and is
         <a href="#ReservedAndPadFields">保留</a>.</p>
         
<center><table border="0" cellpadding="5" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<pre>enum {
    kSymLinkFileType  = 0x736C6E6B, /* 'slnk' */
    kSymLinkCreator   = 0x72686170  /* 'rhap' */
};</pre></td></tr>
</tbody></table></center>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>         
         The pathname stored in a symbolic link is assumed to be a POSIX
         pathname, as used by the Mac OS X BSD and Cocoa programming interfaces.
         It is <b>not</b> a traditional Mac OS, or Carbon, pathname.  The path
         is encoded in UTF-8.  It must be a valid UTF-8 sequence, with no null
         (zero) bytes.  The path may refer to another volume.  The path need
         not refer to any existing file or directory.  The path may be full
         or partial (with or without a leading forward slash). For maximum
         compatibility, the length of the path should be 1024 bytes or less.</p>
</td></tr></tbody></table></center>

<p><a href="#top">返回顶部</a></p>

		<h2><a name="Journal"></a>Journal</h2>
		
		<p>HFS+可以选择启用<b>journal</b>以保证在unmounted失败是卷的完整性（比如掉电或
        系统崩溃）。它只保护volume的结构和元信息，不保护文件内容本身。</p>
		
		<h3>背景</h3>
		
		<p>一个小的改变可能会修改volume上很多地方。如果其中一处修改失败，可能会引起
        其它总是。</p>

		<p>比如，创建一个文件或目录需要添加2个records（自己的record和thread record）。
        一个叶子可能没有足够的空间，所以它会被拆分。这意味着，一些record会被删除并放在一个新
        的node中。如果这里面有任何步骤出了问题，将永远无法还原。</p>

		<p>日志的目的就是确保一系列操作可以完整进行。方法是，把这些操作的拷贝放在一个单独的地方（日志）。
        当真实操作失败时，下一次仍然能够从拷贝中继续。</p>

		<p>一系列相关的操作称之为 <b>transaction</b>。
        当这个操作已写入，那么这个 transaction 就
		<b>committed</b>，并从日志中删除。当把
		transactions 回写到磁盘时，称之为
		<b>replaying</b>。</p>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>         
		Implementations accessing a journaled volume with transactions
		must either refuse to access the volume, or replay the journal
		to be sure the volume is consistent.  If the
		<code>lastModifiedVersion</code> field of the
		<a href="#VolumeHeader">volume header</a> does not match the
		signature of an implementation known to properly use and update
		the journal, then the journal must not be replayed (since it may
		no longer match the on-disk structures, and could cause
		corruption if replayed).</p>
</td></tr></tbody></table></center>

		<h3>Journal的结构</h3>

		<p>如果<a href="#VolumeHeader">volume header</a>的 <code>kHFSVolumeJournaledBit</code>设置了，
        表示已启用 journal。journal包含一个
		journal info block, journal header, 和 journal buffer。
		<b>journal info block</b> 标识了journal header 和 journal buffer的位置和大小。
         <b>journal buffer</b> 保存 transactions。  <b>journal
		header</b> 标记那个journal buffer的transactions是在等待committed。</p>

<center><img src="tn1150_007.png" alt="Overview of an HFS Plus Journal" width="441" height="504" align="bottom">
<p><b>Figure 7</b>. Overview of an HFS+ Journal.</p>
</center>

		<p>在HFS+卷上，journal info block做为一个文件储存。名字是
		<code>".journal_info_block"</code> 并储存在根目录下。
        journal header 和 journal buffer 储存在一起，名字是
		<code>".journal"</code>,，也在根目录下。 
		它们都是连续存放的，一盘情况下,通过文件系统访问不到。</p>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>         
		具体实现应该通过volume header的
		<code>journalInfoBlock</code> 找到日志，而不是由文件名。</p>
</td></tr></tbody></table></center>

		<p>一个transaction包含了许多blocks和它们的位置。<b>block list
		header</b>描述了blocks的数量和大小，位于blocks的后面。</p>
		
<center><img src="tn1150_008.png" alt="A Simple Transaction" width="288" height="360" align="bottom">
<p><b>Figure 8</b>简单的Transaction</p>
</center>

		<p>一个block list headers的大小是固定的，所以
		transaction可能有多个block list headers。如果<code>block_info</code>的
		<code>next</code> 非0，则下个block list header是在同一个transaction。</p>

<center><img src="tn1150_009.png" alt="A Transaction with Multiple Block Lists" width="288" height="657">
<p><b>图 9</b>. 多个block lists的transaction。</p>
</center>

		<p>The journal buffer is treated as a circular buffer. When
		reading or writing the journal buffer, the I/O operation must
		stop at the end of the journal buffer and resume (wrap around)
		immediately following the journal header.  Block list headers or
		the contents of blocks may wrap around in this way.  Only a
		portion of the journal buffer is active at any given time; this
		portion is indicated by the <code>start</code> and
		<code>end</code> fields of the journal header.  The part of the
		journal buffer that is not active contains no meaningful data,
		and must be ignored.</p>
         
		<p>To prevent ambiguity when <code>start</code> equals
		<code>end</code>, the journal is never allowed to be perfectly
		full (all of the journal buffer used by block lists and blocks).
		If the journal was perfectly full, and <code>start</code> was
		not equal to <code>jhdr_size</code>, then <code>end</code> would
		be equal to <code>start</code>.  You would then be unable to
		differentiate between an empty and full journal.</p>

		<p>When the journal is not empty (contains transactions),
		it must be <a href="#ReplayJournal">replayed</a> to be sure the volume
		is consistent.  That is, the data from each of the transactions must be
		written to the correct blocks on disk.</p>
         
         <h3><a name="JournalInfoBlock"></a>Journal Info Block</h3>
         
         <p>The <b>journal info block</b> describes where the journal header and
         journal buffer are stored. The journal info block is stored at the
         beginning of the allocation block whose number is stored in the
         <code>journalInfoBlock</code> field of the
         <a href="#VolumeHeader">volume header</a>.  The journal info block
         is described by the data type <code>JournalInfoBlock</code>.</p>

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct JournalInfoBlock {
    UInt32    flags;
    UInt32    device_signature[8];
    UInt64    offset;
    UInt64    size;
    UInt32    reserved[32];
};
typedef struct JournalInfoBlock JournalInfoBlock;</pre>
    </td>
</tr>
</tbody></table></center>

         <p>结构中各个域的作用如下：</p>
         
         <dl>
            <dt><code>flags</code></dt>
            
            <dd><a href="#JIBFlags">定义</a>。
            <a href="#ReservedAndPadFields">保留</a>.</dd>
            
            <dt><code>device_signature</code></dt>
            
            <dd>This space is <a href="#ReservedAndPadFields">保留</a>
            for describing the device containing the journal when the
            journal is not stored in the volume itself (when
            <code>kJIJournalOnOtherDeviceMask</code> is set).</dd>
            
            <dt><code>offset</code></dt>
            
            <dd>The offset in bytes from the start of the device to
            the start of the journal header.  When the journal is stored
            in the volume itself (<code>kJIJournalInFSMask</code>
            is set), this offset is relative to the start of the volume.</dd>
            
            <dt><code>size</code></dt>
            
            <dd>The size in bytes of the journal, including the journal
            header and the journal buffer.  This size does not include
            the journal info block.</dd>

            <dt><code>reserved</code></dt>
            
            <dd>This space is <a href="#ReservedAndPadFields">保留</a>.</dd>
         </dl>

         <p>The following constants define bit flags in the <code>flags</code> field:
         </p>
         
<a name="JIBFlags"></a><center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>enum {
    kJIJournalInFSMask          = 0x00000001,
    kJIJournalOnOtherDeviceMask = 0x00000002,
    kJIJournalNeedInitMask      = 0x00000004
};</pre>
    </td>
</tr>
</tbody></table></center>

         <p>The values have the following meaning:</p>
         
         <dl>
            <dt><code>kJIJournalInFSMask</code></dt>
            
            <dd>When set, the space for the journal header and
            transactions resides inside the volume being journaled.
            The <code>offset</code> field of the journal info block
            is relative to the start of the volume (allocation
            block number zero).</dd>
            
            <dt><code>kJIJournalOnOtherDeviceMask</code></dt>
            
            <dd>When set, the space for the journal header and
            journal buffer does not reside inside the volume being
            journaled.  The <code>device_signature</code> field
            in the journal info block describes the device containing
            the journal.</dd>

            <dt><code>kJIJournalNeedInitMask</code></dt>
            
            <dd>This bit is set to indicate that the journal header is invalid
            and needs to be initialized.  This bit is typically set when the
            journal is first created, and the space has been allocated; the first
            mount of the journaled volume typically initializes the journal header
            and clears this bit.  When this bit is set, there are no valid transactions
            in the journal.</dd>
         </dl>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>         
		Implementations must currently set
		<code>kJIJournalInFSMask</code>, but not
		<code>kJIJournalOnOtherDeviceMask</code>.  Journals stored on a
		separate device are not currently supported. The format of the
		<code>device_signature</code> field is not yet defined.</p>
</td></tr></tbody></table></center>

         <h3><a name="JournalHeader"></a>Journal Header</h3>
         
         <p>日志的起始是一个journal header，用于描述transactions的位置。
         结构为
         <code>journal_header</code>。<font color="red">注意：它是小端对齐的</font></p>

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>typedef struct journal_header {
    UInt32    magic;
    UInt32    endian;
    UInt64    start;
    UInt64    end;
    UInt64    size;
    UInt32    blhdr_size;
    UInt32    checksum;
    UInt32    jhdr_size;
} journal_header;

#define JOURNAL_HEADER_MAGIC  0x4a4e4c78
#define ENDIAN_MAGIC          0x12345678</pre>
    </td>
</tr>
</tbody></table></center>

         <p>结构中各个域的作用如下：</p>
         
         <dl>
            <dt><code>magic</code></dt>
            
            <dd>总是 <code>JOURNAL_HEADER_MAGIC</code> (0x4a4e4c78)。</dd>

            <dt><code>endian</code></dt>
            
            <dd>总是 <code>ENDIAN_MAGIC</code> (0x12345678)。用于区分机器对齐。</dd>

            <dt><code>start</code></dt>
            
            <dd>最后一个transaction的开始</dd>

            <dt><code>end</code></dt>
            
            <dd>最后一个transaction的结尾。可能比 <code>start</code> 小，这表示
            它从buffer后面折反。如果相等，表示没有transactions需要replayed.</dd>

            <dt><code>size</code></dt>
            
            <dd>journal的大小。包括journal
            header 和 journal buffer。必须等于 
            <a href="#JournalInfoBlock">journal info block</a>的 <code>size</code>。</dd>

            <dt><code>blhdr_size</code></dt>
            
            <dd>一个 <a href="#BlockListHeader">block list header</a>,
            的大小。通常是4096 到 16384。</dd>

            <dt><code>checksum</code></dt>
            
            <dd>校验和，计算<a href="#Checksum">如下
            below</a>。</dd>

            <dt><code>jhdr_size</code></dt>
            
            <dd>journal header的大小。通常等于扇区大小。</dd>
         </dl>

         <h3><a name="BlockListHeader"></a>Block List Header</h3>
         
         <p>The <b>block list header</b> describes a list of blocks
         included in a transaction.  A transaction may include several
         block lists if it modifies more blocks than can be represented
         in a single block list.  The block list header is stored in a
         structure of type <code>block_list_header</code>.</p>

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>typedef struct block_list_header {
    UInt16    max_blocks;
    UInt16    num_blocks;
    UInt32    bytes_used;
    UInt32    checksum;
    UInt32    pad;
    block_info  binfo[1];
} block_list_header;</pre>
    </td>
</tr>
</tbody></table></center>

         <p>结构中各个域的作用如下：</p>
         
         <dl>
            <dt><code>max_blocks</code></dt>
            
            <dd> 此block　list的最大blocks (<code>block_info</code>
            items）数量。用于在内存中记录journal buffer的大小。在磁盘上，此域 <a href="#ReservedAndPadFields">保留</a>。</dd>

            <dt><code>num_blocks</code></dt>
            
            <dd>The number of elements in the <code>binfo</code> array.  Since
            the first element of the <code>binfo</code> array is used to
            chain multiple block lists into a single transaction, the
            actual number of data blocks is <code>num_blocks - 1</code>.
            </dd>

            <dt><code>bytes_used</code></dt>
            
            <dd>The number of bytes occupied in the journal for this block list,
            including the block list header and the data for each of the blocks
            in the list.  The next block list header (if any) will be
            <code>bytes_used</code> bytes from the start of the current block
            list header, wrapping from the end of the journal buffer to the
            start of the journal buffer if needed.</dd>

            <dt><code>checksum</code></dt>
            
            <dd>The <a href="#Checksum">checksum</a> of the block list header,
            including the first element of the <code>binfo</code> array
            (a total of 32 bytes).</dd>

            <dt><code>pad</code></dt>
            
            <dd><a href="#ReservedAndPadFields">保留</a>.</dd>

            <dt><code>binfo</code></dt>
            
            <dd>A variable-sized array of blocks.  The array contains
            <code>num_blocks+1</code> entries.  The first entry is used
            when a single transaction occupies multiple block lists,
            using the <code>next</code> field as described above.  The
            remaining <code>num_blocks</code> entries describe where the
            data from this block list will be written to disk.</dd>
         </dl>

         <p>The first element of the <code>binfo</code> array is
         used to indicate whether the transaction contains additional
         block lists.  Each of the other elements of the
         <code>binfo</code> array represent a single block of data
         in the journal buffer which must be copied to its correct
         location on disk.  结构中各个域的作用如下：</p>

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>typedef struct block_info {
    UInt64    bnum;
    UInt32    bsize;
    UInt32    next;
} block_info;</pre>
    </td>
</tr>
</tbody></table></center>

         <dl>
            <dt><code>bnum</code></dt>
            
            <dd>The sector number where the data in this block
            must be written.  If this field is 0xFFFFFFFFFFFFFFFF (all
            64 bits set), then this block must be skipped and not
            written.  This field is <a href="#ReservedAndPadFields">保留</a> for the first element
            of the <code>binfo</code> array.</dd>

            <dt><code>bsize</code></dt>
            
            <dd>The number of bytes to be copied from the journal buffer
            to the above sector number.  This value will be a
            multiple of 512.  This field is <a href="#ReservedAndPadFields">保留</a> for the first element
            of the <code>binfo</code> array.</dd>

            <dt><code>next</code></dt>
            
            <dd>This field is used while in memory to keep track of
            transactions that span multiple block lists.  If this field
            is zero in the first <code>block_info</code> of a block
            list, then the transaction ends with this block list;
            otherwise, the transaction has one or more additional block
            lists.  This field is meaningful only for the first element
            of the block list array.  The actual on-disk value has no
            meaning beyond testing for zero or non-zero.</dd>
         </dl>         

         <h3><a name="Checksum"></a>Journal Checksums</h3>
         
         <p>The <a href="#JournalHeader">journal header</a> and
         <a href="#BlockListHeader">block list header</a> both contain
         <code>checksum</code> fields.  These checksums can be verified as part of a
         basic consistency check of these structures.  To verify the
         checksum, temporarily set the <code>checksum</code> field to zero and then call
         the <code>calc_checksum</code> routine with the address and size of the
         header being checksummed.  The function result should equal the
         original value of the <code>checksum</code> field.</p>

<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>static int
calc_checksum(unsigned char *ptr, int len)
{
    int i, cksum=0;

    for(i=0; i &lt; len; i++, ptr++) {
        cksum = (cksum &lt;&lt; 8) ^ (cksum + *ptr);
    }

    return (~cksum);
}</pre>
    </td>
</tr>
</tbody></table></center>

         <h3><a name="ReplayJournal"></a>Replaying the Journal</h3>
         
         <p>In order to replay the journal, an implementation just loops
         over the transactions, copying each individual block in the
         transaction from the journal to its proper location on the
         volume.  Once those blocks have been flushed to the media (not
         just the driver!), it may update the journal header to remove
         the transactions.</p>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>         
         Replaying the journal does not guarantee that the temporary files
         associated with <a href="#UnlinkedFiles">open but unlinked</a>
         files are deleted.  After replaying the journal, these temporary
         files may be deleted.</p>
</td></tr></tbody></table></center>

         <p>Here are the steps to replay the journal:</p>
         
         <ol>
         	<li>Read the <a href="#VolumeHeader">volume header</a>
         		into variable <code>vhb</code>.  The volume may have an
         		<a href="#HFSWrapper">HFS wrapper</a>; if so, you will need to use
         		it to determine the location of the volume header.</li>
         	<li>Test the <code>kHFSVolumeJournaledBit</code> in the
         		<code>attributes</code> field of the volume header.  If
         		it is not set, there is no journal to replay, and you
         		are done.</li>
         	<li>Read the <a href="#JournalInfoBlock">journal info block</a>
         		from the allocation block number <code>vhb.journalInfoBlock</code>,
         		into variable <code>jib</code>.</li>
         	<li>If <code>kJIJournalNeedsInitMask</code> is set in <code>jib.flags</code>,
         		the journal was never initialized, so there is no journal to replay.</li>
         	<li>Verify that <code>kJIJournalInFSMask</code> is set and
         		<code>kJIJournalOnOtherDeviceMask</code> is clear in
         		<code>jib.flags</code>.</li>
         	<li>Read the <a href="#JournalHeader">journal header</a> at
         		<code>jib.offset</code> bytes from the start of the volume, and
         		place it in variable <code>jhdr</code>.</li>
         	<li>If <code>jhdr.start</code> equals <code>jhdr.end</code>, the
         		journal does not have any transactions, so there is nothing
         		to replay.</li>
			<li>Set the current offset in the journal (typically a local variable)
				to the start of the journal buffer, <code>jhdr.start</code>.</li>
         	<li>While <code>jhdr.start</code> does not equal <code>jhdr.end</code>,
         		perform the following steps:
				<ol>
					<li>Read a <a href="#BlockListHeader">block list header</a> of
						<code>jhdr.blhdr_size</code> bytes from the current offset
						in the journal into variable <code>blhdr</code>.</li>
					<li>For each block in <code>bhdr.binfo[1]</code> to
						<code>bhdr.binfo[blhdr.num_blocks]</code>, inclusive, copy
						<code>bsize</code> bytes from the current offset in the
						journal to sector <code>bnum</code> on the volume (to byte
						offset <code>bnum*jdhr.jhdr_size</code>).  Remember that
						<code>jhdr_size</code> is the size of a sector, in bytes.</li>
					<li>If <code>bhdr.binfo[0].next</code> is zero, you have completed
						the last block list of the current transaction; set
						<code>jhdr.start</code> to the current offset in the journal.</li>
				</ol>
         	</li>
         </ol>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>         
         Remember that the journal is a circular buffer.  When reading a
         <a href="#BlockListHeader">block list header</a> or block from
         the journal buffer (in the loop described above), you will need
         to check whether it wraps around the end of the journal buffer.
          If it would extend beyond the end of the journal buffer, you
         must stop reading at the end of the journal buffer, and resume
         reading at the start of the journal buffer (offset
         <code>jhdr.jhdr_size</code> bytes from the start of the
         journal).</p>
</td></tr></tbody></table></center>

		<p>After replaying an entire transaction (all blocks
		in a block list, when <code>bhdr.binfo[0]</code> is zero), or after
		replaying all transactions, you may update the value of the <code>start</code>
		field in the <a href="#JournalHeader">journal header</a> to the current
		offset in the journal.  This will remove those block lists from the
		journal since they have been written to their correct locations on disk.</p>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>警告:</b><br>
		You must ensure that previous block writes complete before updating
		the journal header's <code>start</code> field on disk.  One way to
		do this is to issue a flush to the device driver and wait until
		the device driver has written all dirty blocks, and then flush the
		device itself and wait for the device to write all dirty blocks
		to the media.</p>
</td></tr></tbody></table></center>

<p><a href="#top">返回顶部</a></p>

         <h2><a name="HFSX"></a>HFSX</h2>
         
         <p>HFSX is an extension to HFS+ to allow additional features
         that are incompatible with HFS+.  The only such feature currently
         defined is case-sensitive filenames.</p>
         
         <p>HFSX volumes have a signature of <code>'HX'</code>
         (<code>0x4858</code>) in the <code>signature</code> field of the
         <a href="#VolumeHeader">volume header</a>.  The <code>version</code>
         field identifies the version of HFSX used on the volume; the only
         value currently defined is <code>5</code>.  If features are added that
         would be incompatible with older versions (that is, older versions
         cannot safely access or modify the volume because of the new features),
         then a different <code>version</code> number will be used.</p>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>
				A new <code>signature</code> was required because some utilities
				did not use the <code>version</code> field properly.  They
				would attempt to use or repair the volume (including changing the
				<code>version</code> field) when they encountered a
				<code>version</code> value that was not previously documented.</p>
</td></tr></tbody></table></center>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>警告:</b><br>
				If your implementation encounters an HFSX volume with a
				<code>version</code> value it does not recognize, it must
				not attempt to access or repair the volume.  Catastrophic
				data loss may result.  In particular, do <b>NOT</b> change the
				<code>version</code> field.</p>
</td></tr></tbody></table></center>

		<p>It is intended that future HFSX features will result in the definition
		of new <a href="#VolumeAttributes">volume attribute</a> bits, and that
		those bits will be used to indicate which features are in use on the
		volume.</p>
		
		<p>An HFSX volume never has an <a href="#HFSWrapper">HFS wrapper</a>.</p>
		
		<p>In an Apple partition map, the partition type (<code>PMPartType</code>)
		of an HFSX volume is set to "Apple_HFSX".</p>

		<h3><a name="HFSX_V5"></a>HFSX Version 5</h3>
		
		<p>Introduced in Mac OS X 10.3, HFSX version 5 allows volumes with
		case-sensitive file and directory names.  Case-sensitive names
		means that you can have two objects, whose names differ only by
		the case of the letters, in the same directory at the same time.
		For example, you could have "Bob", "BOB", and "bob" in the same
		directory.</p>
		
		<p>An HFSX volume may be either case-sensitive or case-insensitive.
		Case sensitivity (or lack thereof) is global to the volume; the
		setting applies to all file and directory names on the volume.
		To determine whether an HFSX volume is case-sensitive, use the
		<code>keyCompareType</code> field of the <a href="#HeaderRecord">
		B-tree header</a> of the <a href="#CatalogFile">catalog file</a>.
		A value of <code>kHFSBinaryCompare</code> means the volume is
		case-sensitive.  A value of <code>kHFSCaseFolding</code> means the
		volume is case-insensitive.</p>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
			Do not assume that an HFSX volume is case-sensitive.
			Always use the <code>keyCompareType</code> to determine
			case-sensitivity or case-insensitivity.
</p></td></tr></tbody></table></center>

		<p>A case-insensitive HFSX volume (one whose <code>keyCompareType</code>
		is <code>kHFSCaseFolding</code> uses the same <a href="#StringComparisonAlgorithm">
		Unicode string comparison algorithm</a> as HFS+.</p>
		
		<p>A case-sensitive HFSX volume (one whose <code>keyCompareType</code>
		is <code>kHFSBinaryCompare</code>) simply compares each character of
		the name as an unsigned 16-bit integer.  The first character (the one
		with the smallest offset from the start of the string) that is
		different determines the relative order.  The string with the
		numerically smaller character value is ordered before the string
		with the larger character value.  For example, the string "Bob"
		would sort before the string "apple" because the code for the
		character "B" (decimal 66) is less than the code for the character
		"a" (decimal 97).</p>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>                  
			Case-sensitive names do not ignore Unicode "ignorable"
			characters. This means that a single directory may have several
			names which would be considered equivalent using Unicode comparison
			rules, but which are considered distinct on a case-sensitive
			HFSX volume.
</p></td></tr></tbody></table></center>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>                  
			The null character (<code>0x0000</code>), as used in the name
			of the "HFS+ Private Data" directory used by
			<a href="#HardLinks">hard links</a>, sort first with
			case-sensitive compares, but last with case-insensitive
			compares.
</p></td></tr></tbody></table></center>

<p><a href="#top">返回顶部</a></p>

		<h2><a name="MetadataZone"></a>Metadata Zone</h2>
		
		<p>Mac OS X version 10.3 introduced a new policy for determining
		where to allocate space for files, which improves performance
		for most users.  This policy places the volume metadata and
		frequently used small files ("<a href="#HotFile">hot files</a>")
		near each other on disk, which reduces the seek time for typical
		accesses.  This area on disk is known as the <b>metadata
		zone</b>.</p>
		
		<p>The volume metadata are the structures that let the file system
		manage the contents of the volume.  It includes the
		<a href="#AllocationFile">allocation bitmap file</a>,
		<a href="#ExtentsOverflowFile">extents overflow file</a>,
		and the <a href="#CatalogFile">catalog file</a>, and the
		<a href="#Journal">journal file</a>.  The
		<a href="#VolumeHeader">volume header</a> and alternate volume
		header are also metadata, but they have fixed locations within
		the volume, so they are not located in the hot file area.  Mac OS
		X may use a quota users file and quota groups file to manage disk
		space quotas on a volume.  These files aren't strictly metadata,
		but they are included in the metadata zone because of their 
		heavy use by the OS and they are too large to be considered
		ordinary hot files.</p>
		
		<p>Implementations are encouraged not to interfere with the metadata
		zone policy.  For example, a disk optimizer should avoid moving files
		into the metadata zone unless that file is known to be
		frequently accessed, in which case it may be added to the "<a href="#HotFile">hot file</a>" list.  Similarly, files in the
		metadata zone should not be moved elsewhere on disk unless they
		are also removed from the hot file list.</p>
		
		<p>This policy is only applied to volumes whose size is at least
		10GB, and which have <a href="#Journal">journaling</a> enabled.
		The metadata zone is established when the volume is mounted.  The
		size of the zone is based upon the following sizes:</p>
		
		<table border="1">
	<tbody><tr>
		<th>Item</th>
		<th>Contribution to the Metadata Zone size</th>
	</tr>
	<tr>
		<td scope="row"><a href="#AllocationFile">Allocation Bitmap File</a></td>
		<td>Physical size (<code>totalBlocks</code> times the volume's
		allocation block size) of the allocation bitmap file.</td>
	</tr>
	<tr>
		<td scope="row"><a href="#ExtentsOverflowFile">Extents Overflow File</a></td>
		<td>4MB, plus 4MB per 100GB (up to 128MB maximum)</td>
	</tr>
	<tr>
		<td scope="row"><a href="#Journal">Journal File</a></td>
		<td>8MB, plus 8MB per 100GB (up to 512MB maximum)</td>
	</tr>
	<tr>
		<td scope="row"><a href="#CatalogFile">Catalog File</a></td>
		<td>10 bytes per KB (1GB minimum)</td>
	</tr>
	<tr>
		<td scope="row"><a href="#HotFile">Hot Files</a></td>
		<td>5 bytes per KB (10MB minimum; 512MB maximum)</td>
	</tr>
	<tr>
		<td scope="row">Quota Users File</td>
		<td>Described below</td>
	</tr>
	<tr>
		<td scope="row">Quota Groups File</td>
		<td>Described below</td>
	</tr>
</tbody></table>

		<p>In Mac OS X version 10.3, the amount of space reserved for the
		allocation file is actually the minimum allocation file size for
		the volume (the total number of allocation blocks, divided by 8,
		rounded up to a multiple of the allocation block size).  If the
		allocation file is larger than that (which is sometimes done to
		allow a volume to be more easily grown at a later time), then
		there will be less space available for other metadata or
		<a href="#HotFile">hot files</a> in the metadata zone.  This
		is a bug (r. 3522516).</p>
		
		<p>The amount of space reserved for each type of metadata (except for
		the allocation bitmap file) is based on the total size of the volume.
		For the purposes of these computations, the total size of the volume is
		the allocation block size multiplied by the total number of allocation blocks.</p>
		
		<p>The sizes reserved for quota users and groups files are the result of
		complex calculations.  In each case, the size reserved is a value of
		the form <code>(items + 1) * 64</code> bytes, where <code>items</code>
		is based on the size of the volume in gigabytes, rounded down.  For the
		quota users file, <code>items</code> is 256 per gigabyte, rounded up to
		a power of 2, with a minimum of 2048, and a maximum of 2097152 (2M).
		For the quota groups file, <code>items</code> is 32 per gigabyte,
		rounded up to a power of 2, with a minimum of 2048, and a maximum of
		262144 (256K).  The quota files are considered hot files, and occupy
		the <a href="#HotFile">hot file</a> area, even though they are larger
		than the maximum file size normally eligible to be a hot file.</p>
		
		<p>The total size of the metadata zone is the sum of the above sizes,
		rounded up so that the metadata zone is represented by a whole number
		of allocation blocks within the volume bitmap.  That is, the start and
		end of the metadata zone fall on allocation block boundaries in the
		volume bitmap.  That means that the size of the metadata zone is rounded
		up to a multiple of 8 times the square of the allocation block size.
		In Mac OS X version 10.3, the extra space due to the round up of the
		metadata zone is split up between the catalog and the
		<a href="#HotFile">hot file</a> area (2/3 and 1/3, respectively).</p>
		
		<p>The calculations for the extents overflow file and journal file divide
		the total size of the volume by 100GB, rounding down.  Then they add one
		(to compensate for any remainder lost as part of the rounding).  The result
		is then multiplied by 4MB or 8MB, respectively.  If the volume's total
		size is not a multiple of 100GB, this is equivalent to 4MB (or 8MB) per 100GB,
		rounded up.</p>
				
		<p>In Mac OS X version 10.3, the metadata zone is located at the
		start of the volume, following the
		<a href="#VolumeHeader">volume header</a>. The
		<a href="#HotFile">hot file</a> area is located towards the end of
		the metadata zone.</p>
		
		<p>When performing normal file allocations, the allocator will
		skip over the metadata zone.  This ensures that the metadata will be
		less fragmented, and all of the metadata will be located in the
		same area on the disk.  If the area outside the metadata zone is
		exhausted, the allocator will then use space inside the metadata
		zone for normal file allocations.  Similarly, when allocating
		space for metadata, the allocator will use space inside the
		metadata zone first.  If all of the metadata zone is in use,
		then metadata allocations will use space outside the metadata
		zone.</p>
		
		<h2><a name="HotFile"></a>Hot Files</h2>
		
		<p>Most files on a disk are rarely, if ever, accessed.  Most
		frequently accessed (<b>hot</b>) files are small.  To improve
		performance of these small, frequently access files, they are
		moved near the volume's metadata, into the metadata zone.  This
		reduces seek times for most accesses.  As files are moved into
		the metadata zone, they are also defragmented (allocated in a
		single extent), which further improves performance.  This
		process is known as <b>adaptive hot file clustering</b>. </p>
		
		<p><a name="Temperature"></a>The relative importance of a
		frequently used (hot) file is called its <b>temperature</b>. 
		Files with the hottest (largest) temperatures are the ones
		actually moved into the metadata zone. In Mac OS X version 10.3,
		a file's temperature is computed as the number of bytes read
		from the file during the recording period divided by the file's
		size in bytes. This is a measure of how often the file is
		read.</p>

		<p>This section describes the on-disk structures used for
		tracking hot files.  The algorithms used at run time are subject
		to change, and are not documented here.</p>

		<p>Migration of files into or out of the hot file area of the metadata zone is a
		gradual process, based upon the user's actual file access
		patterns. The migration happens in several phases:</p>

		<dl>
		<dt>Recording</dt>
		<dd>Watch file accesses to determine which files are used most</dd>
		
		<dt>Evaluation</dt>
		<dd>Merge recently used hot files with previously found hot files</dd>
		
		<dt>Eviction</dt>
		<dd>Move older and less frequently used hot files out of metadata zone
		to make room for newer, hotter files</dd>

		<dt>Adoption</dt>
		<dd>Move newer and hotter files into the metadata zone</dd>
		</dl>
		
		<h3>Hot File B-Tree</h3>
		
		<p>A <a href="#BTrees">B-Tree</a> is used to keep track of the
		files that currently occupy the hot file area of the <a href="#MetadataZone"> metadata zone</a>.  The hot file B-tree is an
		ordinary file on the volume (that is, it has records in the <a href="#CatalogFile">catalog</a>). It is a file named
		"<code>.hotfiles.btree</code>" in the root directory. To avoid
		accidental manipulation of this file, the
		<code>kIsInvisible</code> and <code>kNameLocked</code> bits in
		the <code>finderFlags</code> field of the <a href="#FinderInfo">Finder info</a> should be set.</p>
		
		<p>The node size of the hot file B-tree is at least 512 bytes,
		and is typically the same as the the volume's allocation block
		size.  Like other B-trees on an HFS+ volume, the key length
		field is 16 bits, and <code>kBTBigKeysMask</code> is set in the
		B-tree header's <code>attributes</code>.  The
		<code>btreeType</code> in the <a href="#HeaderRecord">header
		record</a> must be set to <code>kUserBTreeType</code>.</p>
		
		<p>The B-tree's <a href="#UserDataRecord">user data record</a>
		contains information about hot file recording.  The format of the user
		data is described by the <code>HotFilesInfo</code> structure:</p>
		
<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>#define HFC_MAGIC   0xFF28FF26
#define HFC_VERSION 1
#define HFC_DEFAULT_DURATION     (3600 * 60)
#define HFC_MINIMUM_TEMPERATURE  16
#define HFC_MAXIMUM_FILESIZE     (10 * 1024 * 1024)
char hfc_tag[] = "CLUSTERED HOT FILES B-TREE     ";

struct HotFilesInfo {
    UInt32  magic;
    UInt32  version;
    UInt32  duration;    /* duration of sample period */
    UInt32  timebase;    /* recording period start time */
    UInt32  timeleft;    /* recording period stop time */
    UInt32  threshold;
    UInt32  maxfileblks;
    UInt32  maxfilecnt;
    UInt8   tag[32];
};
typedef struct HotFilesInfo HotFilesInfo;</pre>
    </td>
</tr>
</tbody></table></center>

		<p>结构中各个域的作用如下：</p>
		<dl>
		<dt><code>magic</code></dt>
		<dd>Must contain the value <code>HFC_MAGIC</code> (0xFF28FF26).</dd>

		<dt><code>version</code></dt>
		<dd>Contains the version of the <code>HotFilesInfo</code>
		structure.  Version 1 of the structure is described here.
		If your implementation encounters any other version number,
		it should not read or modify the hot file B-tree.</dd>
		
		<dt><code>duration</code></dt>
		<dd>Contains the duration of the current recording phase, in seconds.
		In Mac OS X 10.3, this value is typically <code>HFC_DEFAULT_DURATION</code>
		(60 hours).</dd>

		<dt><code>timebase</code></dt>
		<dd>Contains the time that the current recording phase began, in seconds
		since Jan 1, 1970 GMT.</dd>

		<dt><code>timeleft</code></dt>
		<dd>Contains the time remaining in the current recording phase, in seconds.</dd>

		<dt><code>threshold</code></dt>
		<dd>Contains the minimum temperature for a file to be eligible to be
		moved into the hot file area.  Files whose temperature is less than
		this value will be moved out of the hot file area.</dd>

		<dt><code>maxfileblks</code></dt>
		<dd>Contains the maximum file size, in allocation blocks, for a
		file to be eligible to be moved into the hot file area.  Files
		larger than this size will not be moved into the hot file area. 
		In Mac OS X 10.3, this value is typically
		<code>HFC_MAXIMUM_FILESIZE</code> divided by the volume's
		allocation block size.</dd>

		<dt><code>maxfilecnt</code></dt>
		<dd>Contains the maximum number of files to place into the hot file
		area.  Note that the hot file area may actually contain more than
		this number of files, especially if they previously existed in the
		hot file area before the beginning of the recording phase.  This number
		represents the number of files that the hot file recording code
		intents to track and eventually place into the hot file area.</dd>

		<dt><code>tag</code></dt>
		<dd>Contains the null-terminated (C-style) string containing the
		ASCII text
		<code>"CLUSTERED HOT FILES B-TREE     "</code> (not including the
		quotes).  Note that the last six bytes are five spaces and the
		null (zero) byte.  This field exists to make it easier to recognize
		the hot file B-tree when debugging or using a disk editor.  An
		implementation should not attempt to verify or change this field.</dd>
		</dl>

		<h4>Hot File Record Key</h4>
		<p>A key in the hot file B-tree is of type <code>HotFileKey</code>.</p>
		
<center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>struct HotFileKey {
    UInt16   keyLength;
    UInt8    forkType;
    UInt8    pad;
    UInt32   temperature;
    UInt32   fileID;
};
typedef struct HotFileKey HotFileKey;

#define HFC_LOOKUPTAG   0xFFFFFFFF
#define HFC_KEYLENGTH   (sizeof(HotFileKey) - sizeof(UInt32))</pre>
    </td>
</tr>
</tbody></table></center>

		<p>结构中各个域的作用如下：</p>
		
		<dl>
		<dt><code>keyLength</code></dt>
		<dd>The length of a hot file key, not including the <code>keyLength</code>
		field itself.  Hot file keys are of fixed size.  This field must contain
		the value 10.</dd>

		<dt><code>forkType</code></dt>
		<dd>Indicates whether the fork being tracked is a data fork
		(value <code>0x00</code>) or a resource fork (value <code>0xFF</code>).
		In Mac OS X version 10.3, only data forks are eligible for placement
		into the hot file area.</dd>

		<dt><code>pad</code></dt>
		<dd>An implementation must treat this as a
		<a href="#ReservedAndPadFields">pad</a> field.</dd>

		<dt><code>temperature</code></dt>
		<dd>The fork's <a href="#Temperature">temperature</a>.  For hot file
		thread records, this field contains the value <code>HFC_LOOKUPTAG</code>
		(<code>0xFFFFFFFF</code>).</dd>

		<dt><code>fileID</code></dt>
		<dd>The <a href="#CNID">catalog node ID</a> of the file being tracked.</dd>
		</dl>
		
		<p>Hot file keys are compared first by <code>temperature</code>,
		then <code>fileID</code>, and lastly by <code>forkType</code>. 
		All of these comparisons are unsigned.</p>
		
		<h4>Hot File Records</h4>
		
		<p>Much like the <a href="#CatalogFile">catalog file</a>,
		the hot file B-tree stores two kinds of records: hot file records and thread
		records.  Every fork in the hot file area has both a hot file record and
		a thread record in the hot file B-tree.  Hot file records are used to find
		hot files based on their temperature.  Thread records are used to find
		hot files based on their <a href="#CNID">catalog node ID</a> and fork type.</p>
		
		<p>Thread records in the hot file B-tree use a special value
		(<code>HFC_LOOKUPTAG</code>) in the <code>temperature</code>
		field of the key.  The data for a thread record is the
		<code>temperature</code> of that fork, stored as a
		<code>UInt32</code>.  So, given a <a href="#CNID">catalog node
		ID</a> and fork type, it is possible to construct a key for the
		fork's thread record.  If a thread record exists, you can get
		the temperature from the thread's data to construct the key for
		the hot file record.  If a thread record does not exist, then
		the fork is not being tracked as a hot file.</p>
		
		<p>Hot file records use all of the key fields as described
		above. The data for a hot file record is 4 bytes. The data in a
		hot file record is not meaningful. To aid in debugging, Mac OS X
		version 10.3 typically stores the first four bytes of the file
		name (encoded in UTF-8), or the ASCII text "????".</p>
		
		<p>When an implementation changes a hot file's temperature, the
		old hot file record must be removed, a new hot file with the new
		temperature must be inserted, and the thread record's data must
		be changed to contain the new temperature.</p>
		
		<h3>Recording Hot File Temperatures</h3>
		
		<p>The recording phase gathers information about file usage over time.
		In order to gather useful statistics, the recording phase may last longer
		than the duration of a single mount.  Therefore, information about file
		usage is stored on disk so that it can accumulate over time.</p>
		
		<p>The <code>clumpSize</code> field of the <a href="tn1150.html">
		fork data structure</a> is used to record the amount of data actually
		read from a fork.  Since the field is only 32 bits long, it stores
		the number of allocation blocks read from the file.  The fork's
		temperature can be computed by dividing its <code>clumpSize</code> by
		its <code>totalBlocks</code>.</p>

<p><a href="#top">返回顶部</a></p>
         
         <h2><a name="UnicodeSubtleties"></a>Unicode Subtleties</h2>
         
         <p>HFS+ makes heavy use of Unicode strings to store file
         and folder names. However, Unicode is still evolving, and
         its use within a file system presents a number of
         challenges. This section describes some of the challenges,
         along with the solutions used by HFS+.</p>
         
         <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
         
         Before reading this section, you should read
         <a href="#HFSPlusNames">HFS+ Names</a>.</p>
         </td></tr></tbody></table></center>
         
         <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
         
         An implementation must not use the Unicode utilities
         implemented by its native platform (for decomposition and
         comparison), unless those algorithms are equivalent to the
         HFS+ algorithms defined here, and are guaranteed to be
         so forever. This is rarely the case. Platform algorithms
         tend to evolve with the Unicode standard. The HFS+
         algorithms cannot evolve because such evolution would
         invalidate existing HFS+ volumes.</p>
         </td></tr></tbody></table></center>
         
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>         
         The Mac OS Text Encoding Converter provides several
         constants that let you convert to and from the canonical,
         decomposed form stored on HFS+ volumes. When using
         <code>CreateTextEncoding</code> to create a text encoding,
         you should set the <code>TextEncodingBase</code> to
         <code>kTextEncodingUnicodeV2_0</code>, set the
         <code>TextEncodingVariant</code> to
         <code>kUnicodeCanonicalDecompVariant</code>, and set the
         <code>TextEncodingFormat</code> to
         <code>kUnicode16BitFormat</code>. Using these values ensures
         that the Unicode will be in the same form as on an HFS+
         volume, even as the Unicode standard evolves.</p>
</td></tr></tbody></table></center>

<h3><a name="CanonicalDecomposition"></a>Canonical Decomposition</h3>

         <p>Unicode allows some sequences of characters to be
         represented by multiple, equivalent forms. For example, the
         character "<img src="tn1150_005.gif" width="7" height="11" align="bottom" alt="1150.5.gif">"
         can be represented as the single Unicode character
         u+00E9 (latin small letter e with acute), or as
         the two Unicode characters u+0065 and u+0301 (the letter "e"
         plus a combining acute symbol).</p>
         
         <p>To reduce complexity in the B-tree key comparison
         routines (which have to compare Unicode strings), HFS+
         defines that Unicode strings will be stored in fully
         decomposed form, with composing characters stored in
         canonical order. The other equivalent forms are illegal in
         HFS+ strings. An implementation must convert these
         equivalent forms to the fully decomposed form before storing
         the string on disk.</p>
         
         <p>The <a href="http://developer.apple.com/library/mac/technotes/tn/tn1150table.html">Unicode Decomposition</a>
         table contains a list of characters that are illegal as part
         of an HFS+ string, and the equivalent character(s) that
         must be used instead. Any character appearing in a column
         titled "Illegal", must be replaced by the character(s) in
         the column immediately to the right (titled "Replace With").
         </p>
         
<center><table border="0" width="550">
<tbody><tr><td>
<p><b>提示:</b><br>         
         Mac OS versions 8.1 through 10.2.x used decompositions based on
         Unicode 2.1.  Mac OS X version 10.3 and later use decompositions
         based on Unicode 3.2.  Most of the characters whose decomposition
         changed are not used by any Mac encoding, so they are unlikely to
         occur on an HFS+ volume.  The MacGreek encoding had the largest
         number of decomposition changes.</p>
         
         <p>The Unicode decomposition table mentioned above indicates
         which decompositions were added, removed, or changed between
         Unicode 2.1 and Unicode 3.2.</p>
</td></tr></tbody></table></center>

         <p>In addition, the Korean Hangul characters with codes in
         the range u+AC00 through u+D7A3 are illegal and must be
         replaced with the equivalent sequence of conjoining jamos,
         as described in the Unicode 2.0 book, section 3.10.</p>
         

                  <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
                  
                  The characters with codes in the range u+2000
                  through u+2FFF are punctuation, symbols, dingbats,
                  arrows, box drawing, etc. The u+24xx block, for
                  example, has single characters for things like
                  "(a)". The characters in this range are
                  <em>not</em> fully decomposed; they are left
                  unchanged in HFS+ strings. This allows strings
                  in Mac OS encodings to be converted to Unicode and
                  back without loss of information. This is not
                  unnatural since a user would not necessarily expect
                  a dingbat "(a)" to be equivalent to the three
                  character sequence "(", "a", ")" in a file name.</p>
                  
                  <p>The characters in the range u+F900 through u+FAFF
                  are CJK compatibility ideographs, and are <em>not</em>
                  decomposed in HFS+ strings.</p>
              </td></tr></tbody></table></center>
         
         <p>So, for the example given earlier, "<img src="tn1150_006.gif" width="7" height="11" align="bottom" alt="1150.5.gif">"
         must be stored as the two Unicode characters u+0065 and
         u+0301 (in that order). The Unicode character u+00E9 may not
         appear in a Unicode string used as part of an HFS+
         B-tree key.</p>
         
         <h3><a name="StringComparisonAlgorithm"></a>Case-Insensitive
         String Comparison Algorithm</h3>
         
         <p>In HFS+ and case-insensitive <a href="#HFSX">HFSX</a>,
         strings must be compared in a case-insensitive fashion. The
         Unicode standard does not strictly define upper and lower
         case equivalence, although it does suggest some equivalences.
         The HFS+ string comparison algorithm (defined below)
         include a concrete case equivalence definition. An
         implementation must use the equivalence expressed by this
         algorithm.</p>
         
         <p>Furthermore, Unicode requires that certain formatting
         characters be ignored (skipped over) during string
         comparisons. The algorithm and tables used for case
         equivalence also arrange to ignore these characters. An
         implementations must ignore the characters that are ignored
         by this algorithm.</p>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>         
         Case-sensitive <a href="#HFSX">HFSX</a> volumes do
         <em>not</em> ignore the Unicode ignorable characters.
         Those characters are significant for the purposes of
         name comparion on case-sensitive HFSX.</p>
</td></tr></tbody></table></center>
         
         <p>The HFS+ case-insensitive string
         comparison algorithm is defined by the <code>FastUnicodeCompare</code>
         routine, shown below. This routine returns a value that
         tells the caller how the strings are ordered relative to
         each other: whether the first string is less than, equal to,
         or greater than the second string. An HFS+ implementation
         may use this routine directly, or use another routine that
         produces the same relative ordering.</p>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>         
         The <code>FastUnicodeCompare</code> routine does not handle
         composed Unicode characters since they are illegal in HFS+ strings. As described in
         <a href="#CanonicalDecomposition">Canonical
         Decomposition</a>, all HFS+ strings must be fully
         decomposed, with composing characters in canonical order.</p>
</td></tr></tbody></table></center>

         <center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>/*
    FastUnicodeCompare - Compare two Unicode strings;
        produce a relative ordering

      IF              RESULT
  --------------------------
  str1 &lt; str2     =&gt;  -1
  str1 = str2     =&gt;   0
  str1 &gt; str2     =&gt;  +1

  The lower case table starts with 256 entries (one for
  each of the upper bytes of the original Unicode char).
  If that entry is zero, then all characters with that
  upper byte are already case folded.  If the entry is
  non-zero, then it is the _index_ (not byte offset) of
  the start of the sub-table for the characters with
  that upper byte.  All ignorable characters are folded
  to the value zero.

  In pseudocode:

      Let c = source Unicode character
      Let table[] = lower case table

      lower = table[highbyte(c)]
      if (lower == 0)
          lower = c
      else
          lower = table[lower+lowbyte(c)]

      if (lower == 0)
          ignore this character

  To handle ignorable characters, we now need a loop to
  find the next valid character.  Also, we can't pre-compute
  the number of characters to compare; the string length
  might be larger than the number of non-ignorable characters.
  Further, we must be able to handle ignorable characters at
  any point in the string, including as the first or last
  characters.  We use a zero value as a sentinel to detect
  both end-of-string and ignorable characters.  Since the
  File Manager doesn't prevent the NULL character (value
  zero) as part of a file name, the case mapping table is
  assumed to map u+0000 to some non-zero value (like 0xFFFF,
  which is an invalid Unicode character).

  Pseudocode:

      while (1) {
          c1 = GetNextValidChar(str1) -- returns zero if
                                      -- at end of string
          c2 = GetNextValidChar(str2)

          if (c1 != c2) break; -- found a difference

          if (c1 == 0)  -- reached end of string on
                        -- both strings at once?
              return 0; -- yes, so strings are equal
      }

        -- When we get here, c1 != c2.  So, we just
        -- need to determine which one is less.
      if (c1 &lt; c2)
          return -1;
      else
          return 1;
*/

SInt32 FastUnicodeCompare (
        register ConstUniCharArrayPtr str1,
        register ItemCount length1,
        register ConstUniCharArrayPtr str2,
        register ItemCount length2) {
    register UInt16     c1,c2;
    register UInt16     temp;
    register UInt16*    lowerCaseTable;

    lowerCaseTable = gLowerCaseTable;

    while (1) {
            /* Set default values for c1, c2 in
            case there are no more valid chars */
        c1 = 0;
        c2 = 0;
            /* Find next non-ignorable char from
            str1, or zero if no more */
        while (length1 &amp;&amp; c1 == 0) {
            c1 = *(str1++);
            --length1;
                /* is there a subtable for
                this upper byte? */
            if ((temp = lowerCaseTable[c1&gt;&gt;8]) != 0)
                    /* yes, so fold the char */
                c1 = lowerCaseTable[temp + (c1 &amp; 0x00FF)];
        }
            /* Find next non-ignorable char
            from str2, or zero if no more */
        while (length2 &amp;&amp; c2 == 0) {
            c2 = *(str2++);
            --length2;
                   /* is there a subtable
                   for this upper byte? */
           if ((temp = lowerCaseTable[c2&gt;&gt;8]) != 0)
                       /* yes, so fold the char */
                c2 = lowerCaseTable[temp + (c2 &amp; 0x00FF)];

        }
            /* found a difference, so stop looping */
        if (c1 != c2)
            break;
            /* did we reach the end of
            both strings at the same time? */
        if (c1 == 0)
                /* yes, so strings are equal */
            return 0;
    }
    if (c1 &lt; c2)
        return -1;
    else
        return 1;
}


    /*  The lower case table consists of a 256-entry high-byte
    table followed by some number of 256-entry subtables. The
    high-byte table contains either an offset to the subtable
    for characters with that high byte or zero, which means
    that there are no case mappings or ignored characters in
    that block. Ignored characters are mapped to zero. */


UInt16 gLowerCaseTable[] = {
    /* High-byte indices ( == 0 if no case mapping and
    no ignorables ) Full data tables omitted for brevity.
    See the Downloadables section for URL to download
    the code. */
};</pre>
    </td>
</tr>
</tbody></table></center>


<p><a href="#top">返回顶部</a></p>

         <h2><a name="HFSWrapper"></a>HFS Wrapper</h2>
         
         <p>An HFS+ volume may be contained within an HFS volume
         in a way that makes the volume look like an HFS volume to
         systems without HFS+ support. This has a two important
         advantages:</p>
         
         <ol>
            <li>It allows a computer with HFS (but no HFS+)
            support in ROM to start up from an HFS+ volume. When
            creating the wrapper, Mac OS includes a System file
            containing the minimum code to locate and mount the
            embedded HFS+ volume and continue booting from its
            System file.</li>
            
            <li>It improves the user experience when an HFS+
            volume is inserted in a computer that has HFS support but
            no HFS+ support. On such a computer, the HFS wrapper
            will be mounted as a volume, which prevents error dialogs
            that might confuse the user into thinking the volume is
            empty, damaged, or unreadable. The HFS wrapper may also
            contain a Read Me document to explain the steps the user
            should take to access their files.</li>
         </ol>
         
         <p>The rest of this section describes how the HFS wrapper is
         laid out and how the HFS+ volume is embedded within the
         wrapper.</p>


         <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
         
         This section does not describe the HFS+ volume format;
         instead, it describes additions to the HFS volume format
         that allow an HFS+ volume (or some other volume) to be
         embedded in an HFS volume. However, as all Mac OS volumes
         are formatted with an HFS wrapper, all implementations
         should be able to parse the wrapper to find the embedded HFS+ volume.</p>
</td></tr></tbody></table></center>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>         
         An HFS+ volume is not required to have an HFS wrapper.
         In that case, the volume will start at the beginning of
         the disk, and the volume header will be at offset 1024 bytes.
         However, Apple software currently initializes all HFS+
         volumes with an HFS wrapper.</p>
</td></tr></tbody></table></center>


         <h3>HFS Master Directory Block</h3>
         
         <p>An HFS volume always contains a Master Directory Block
         (MDB), at offset 1024 bytes. The MDB is similar to an HFS+
         <a href="#VolumeHeader">volume header</a>. In order to
         support volumes embedded within an HFS volume, several
         unused fields of the MDB have been changed, and are now used
         to indicate the type, location, and size of the embedded
         volume.</p>
         
         <p>What was formerly the <code>drVCSize</code> field (at
         offset 0x7C) is now named <code>drEmbedSigWord</code>. This
         two-byte field contains a unique value that identifies the
         type of embedded volume. When an HFS+ volume is
         embedded, <code>drEmbedSigWord</code> must be
         <code>kHFSPlusSigWord</code> (<code>'H+'</code>), the same
         value stored in the <code>signature</code> field of an HFS+ volume header.</p>
         
         <p>What were formerly the <code>drVBMCSize</code> and
         <code>drCtlCSize</code> fields (at offset <code>0x7E</code>)
         have been combined into a single field occupying four bytes.
         The new structure is named <code>drEmbedExtent</code> and is
         of type <code>HFSExtentDescriptor</code>. It contains the
         starting allocation block number (<code>startBlock</code>)
         where the embedded volume begins and number of allocation
         blocks (<code>blockCount</code> ) the embedded volume
         occupies. The embedded volume must be contiguous. Both of
         these values are in terms of the HFS wrapper's allocation
         blocks, not HFS+ allocation blocks.</p>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>         
         The description of the HFS volume format in
         <a href="http://developer.apple.com/techpubs/mac/Files/Files-102.html">Inside
         Macintosh: Files</a> describes these fields as being used to
         store the size of various caches, and labels each one as
         "used internally".</p>
</td></tr></tbody></table></center>

         <p>To actually find the embedded volume's location on disk,
         an implementation must use the <code>drAlBlkSiz</code> and
         <code>drAlBlSt</code> fields of the MDB. The
         <code>drAlBlkSiz</code> field contains the size (in bytes)
         of the HFS allocation blocks. The <code>drAlBlSt</code>
         field contains the offset, in 512-byte blocks, of the
         wrapper's allocation block 0 relative to the start of the
         volume.</p>


         <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
         
         This embedding introduces a transform between HFS+
         volume offsets and disk offsets. The HFS+ volume exists
         on a virtual disk embedded within the real disk. When
         accessing an HFS+ structure on an embedded disk, an
         implementation must add the offset of the embedded disk to
         the HFS+ location. Listing 2 shows how one might do this,
         assuming 512-byte sectors.
         </p>
         </td></tr></tbody></table></center>
         
         
      
         <center><table border="0" cellpadding="5" width="550">
<tbody><tr>
    <td bgcolor="#E6E6E6">
<pre>static UInt32 HFSPlusSectorToDiskSector(UInt32 hfsPlusSector)
{
    UInt32 embeddedDiskOffset;

    embeddedDiskOffset = gMDB.drAlBlSt +
                         gMDB.drEmbedExtent.startBlock * (drAlBlkSiz / 512)
    return embeddedDiskOffset + hfsPlusSector;
}</pre>
    </td>
</tr>
<tr>
    <td>
<p><b>Listing 2.</b> Sector transform for
         embedded volumes.</p>
    </td>
</tr>
</tbody></table></center>
     

         <p>In order to prevent accidentally changing the files in
         the HFS wrapper, the wrapper volume must be marked as
         software-write-protected by setting
         <code>kHFSVolumeSoftwareLockBit</code> in the
         <code>drAtrb</code> (volume attributes) field of the MDB.
         All correct HFS implementations will prevent any changes to
         the wrapper volume.</p>
         
         <p>To improve performance of HFS+ volumes, the size of
         the wrapper's allocation blocks should be a multiple of the
         size of the HFS+ volume's allocation blocks. In
         addition, the wrapper's allocation block start
         (<code>drAlBlSt</code>) should be a multiple of the HFS+
         volume's allocation block size (or perhaps 4 KB, if the HFS+ allocation blocks are larger). If these recommendations
         are followed, the HFS+ allocation blocks will be
         properly aligned on the disk. And, if the HFS+
         allocation block size is a multiple of the sector size,
         then blocking and deblocking at the device driver level
         will be minimized.</p>
         
         <h3>Allocating Space for the Embedded Volume</h3>
         
         <p>The space occupied by the embedded volume must be marked
         as allocated in the HFS wrapper's volume bitmap (similar to
         the HFS+ <a href="#AllocationFile">allocation file</a>)
         and placed in the HFS wrapper's bad block file (similar to
         the HFS+ <a href="#BadBlockFile">bad block file</a>).
         This doesn't mean the blocks are actually bad; it merely
         prevents the HFS+ volume from being overwritten by newly
         created files in the HFS wrapper, being deleted
         accidentally, or being marked as free, usable space by HFS
         disk repair utilities.</p>
         
         <p>The <code>kHFSVolumeSparedBlocksMask</code> bit of the
         <code>drAtrb</code> (volume attributes) field of the MDB
         must be set to indicate that the volume has a bad blocks
         file.</p>

<h3>Read Me and System Files</h3>


         <center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>重要:</b><br>
         
         This section is not part of the HFS+ volume format. It
         describes how the existing Mac OS implementation of HFS+
         creates HFS wrappers. It is provided for your information
         only.</p>
</td></tr></tbody></table></center>

         <p>As initialized by the Mac OS Disk Initialization Package,
         the HFS wrapper volume contains five files in the root
         folder.</p>
         
         <ul>
            <li>Read Me -- The Read Me file, whose name is actually
            "Where_have_all_my_files_gone?", contains text explaining
            that this volume is really an HFS+ volume but the
            contents cannot be accessed because HFS+ is not
            currently installed on the computer. It also describes
            the steps needed to install HFS+ support. Localized
            system software will also create a localized version of
            the file with localized file name and text content.</li>
            
            <li>System and Finder (invisible) -- The System file
            contains the minimum code to locate and mount the
            embedded HFS+ volume, and to continue booting from
            the System file in the embedded volume. The Finder file
            is empty; it is there to prevent older versions of the
            Finder from de-blessing the wrapper's root directory,
            which would prevent booting from the volume.</li>
            
            <li>Desktop DB and Desktop DF (invisible) -- The Desktop
            DB and Desktop DF files are an artifact of the way the
            files on the wrapper volume are created.</li>
         </ul>
         
         <p>In addition, the root folder is set as the blessed folder
         by placing its folder ID in the first <code>SInt32</code> of
         the <code>drFndrInfo</code> (Finder information) field of
         the MDB.</p>
     

<p><a href="#top">返回顶部</a></p>

         
         <h2><a name="VolumeConsistencyChecks"></a>Volume Consistency Checks</h2>
         
         <p>An HFS+ volume is a complex data structure,
         consisting of many different inter-related data structures.
         Inconsistencies between these data structures could cause
         serious data loss. When an HFS+ implementation mounts a
         volume, it must perform basic consistency checks to ensure
         that the volume is consistent. In addition, the
         implementation may choose to implement other, more advanced,
         consistency checks.</p>
         
         <p>Many of these consistency checks take a significant
         amount of time to run. While a safe implementation might run
         these checks every time a volume is mounted, most
         implementations will want to rely on the correctness of the
         previous implementation that modified the disk. The
         implementation may avoid unnecessary checking by determining
         whether the volume was last unmounted cleanly. If it was,
         the implementation may choose to skip a consistency check.
         </p>
         
         <p>An implementation can determine whether a volume was
         unmounted cleanly by looking at various flag bits in the
         volume header. See <a href="#VolumeAttributes">Volume
         Attributes</a> for details.</p>
         
         <h3><a name="CNIDCheck"></a>Next Catalog Node ID Consistency Check</h3>
         
         <p>For an HFS+ volume to work correctly with
         many implementations, it is vital that the <code>nextCatalogID</code>
         field of the <a href="#VolumeHeader">volume header</a> be greater than
         all <a href="#CNID">CNIDs</a> currently used in the
         catalog file. The algorithm to ensure this is as follows.
         </p>
         
         <ul>
            <li>The implementation must iterate through all the leaf
            nodes of the catalog file, looking for file and folder
            records, determining the maximum CNID of any file or
            folder in the catalog.</li>
            
            <li>Once it knows the maximum CNID value, the
            implementation must set <code>nextCatalogID</code> to a
            value greater than it.</li>
         </ul>

<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>提示:</b><br>         
         The consistency check of <code>nextCatalogID</code> must be
         skipped if <code>kHFSCatalogNodeIDsReusedBit</code> is set
         in the <code>attributes</code> field of the
         <a href="#VolumeHeader">volume header</a>.</p>
</td></tr></tbody></table></center>

<h3><a name="AllocationFileConsistencyCheck"></a>Allocation File
一致性检查</h3>


         <p>为了保证HFS+ volume工作正常，所有分配的block都必须在allocation　file
         标记为占用。该算法如下：</p>
         
         <ul>
            <li>首先遍历allocation　file，将所有分配的block设置为空闲。
            （出于性能考虑，这一步可以跳过。这可能出现一些block即使没有被任何
            extent使用也标记为占用）</li>
            
            <li>前１536和后1024标记为占用。它们是<a href="#VolumeHeader">volume
            header</a>要求保留的。</li>
            
            <li>将特殊文件（catalog file, extents overflow file, allocation
            file, attributes file, startup file）使用的
            extent标记为占用。</li>
            
            <li>遍历catalog　file的所有叶node，将它们使用的extents标记（在
            data和resource的<code>HFSPlusForkData</code> 结构中）。</li>
            
            <li>遍历 <a href="#ExtentsOverflowFile">extents overflow
            file</a>的叶node，标记所有extent records里的block为占用。</li>
            
            <li>遍历attributes file的叶node，标记所有fork data attributes和
            extension attributes里的block为占用。</li>
         </ul>
      
<center><table border="0" width="550">
<tbody><tr><td bgcolor="#E6E6E6">
<p><b>警告:</b><br>
         
         为了保护数据不丢失，每次mount时都应该检查。已分配的block没有标记
         是很严重的；其次是没有使用block标记为占用。</p>
</td></tr></tbody></table></center>

<p><a href="#top">返回顶部</a></p>

         <h2><a name="Summary"></a>Summary</h2>
         
         <p>Volume format specifications are <del>fun</del> <ins>exhausting</ins>.</p>
      

<p><a href="#top">返回顶部</a></p>

		<h2><a name="References"></a>References</h2>

            <p><a href="http://developer.apple.com/techpubs/mac/Files/Files-2.html">Inside
            Macintosh: Files</a>, especially the
            <a href="http://developer.apple.com/techpubs/mac/Files/Files-99.html#HEADING99-0">Data
            Organization on Volumes</a> section.</p>
            
            <p><a href="http://developer.apple.com/documentation/Carbon/Reference/Finder_Interface/index.html">
            Finder Interface Reference</a> section of the Carbon user experience documentation.</p>
            
            <p>
            <a href="http://developer.apple.com/technotes/tn/tn1189.html">
            Technical Note 1189: The Monster Disk Driver Technote</a>,
            especially the
            <a href="http://developer.apple.com/technotes/tn/tn1189.html#SecretsOfThePartitionMap">
            Secrets of the Partition Map</a> section.</p>
            
            <p><cite>Algorithms in C</cite>, Robert Sedgewick,
            Addison-Wesley, 1992, especially the section on B-trees.</p>

         <h2><a name="Changes"></a>Change History</h2>
         
         
         <table border="0" cellpadding="3" width="544">
            <tbody><tr>
               <td width="100">
                  <p align="center">01-February-1999</p>
               </td><td>
<p>Originally published.</p>
               </td></tr>
            <tr>
               <td width="100">
<p align="center">01-March-1999</p>
               </td><td>
<p>Updated to include a warning about initializing disks with a
<a href="#SmallAllocationBlockWarning">small allocation block size</a>.</p>
               </td></tr>
            <tr>
               <td width="100">
<p align="CENTER">18-January-2000</p>
               </td><td>
<p>Updated to clarify the allocation block usage and placement of the
alternate volume header on volumes where the disk size is
not an <a href="#OddSizeVolumes">even multiple of the
allocation block size</a>.</p>
               </td></tr>
            <tr>
               <td width="100" valign="TOP">
<p align="CENTER">2-Mar-2004</p>
               </td><td>
<p>Added information about the <a href="#Journal">journal</a>.</p>
<p>Updated the <a href="#HFSPlusPermissions">HFS+ Permissions</a> section
to describe the way Mac OS X uses permissions on disk.</p>
<p>Added the <a href="#HardLinks">Hard Links</a> and <a href="#Symlinks">
Symbolic Links</a> sections to describe how Mac OS X implements hard and symbolic links.</p>
<p>Added information on how <a href="#CNID">catalog node IDs</a> can wrap
around and be reused, in which case the <a href="#CNIDCheck">CNID consistency
check</a> must be skipped.</p>
<p>Added details about the <a href="#VolumeFinderInfo">Finder information</a>
in the <a href="#VolumeHeader">volume header</a>.  Added a section on the
<a href="#FinderInfo">Finder information</a> for files and directories.</p>
<p>Added a section about <a href="#HFSX">HFSX</a>, an extension of HFS+
that allows for case-sensitive file and directory names.</p>
<p>Added a section about how Mac OS X version 10.3 uses a
<a href="#MetadataZone">Metadata Zone</a> and
<a href="#HotFile">adaptive hot file clustering</a>.</p>

               </td></tr>
         </tbody></table>
         
<p><a href="#top">返回顶部</a></p>
         
         <h2 style="display: none; "><a name="Downloads"></a>Downloadables</h2>
         
         <center style="display: none; "><table border="0" cellpadding="3" width="100%">
              <tbody><tr>
               <td width="50">
<p align="CENTER"><img src="bluebook.gif" width="22" height="23" align="middle" alt="Bluebook.gif"></p>
               </td><td>
<p>FastUnicodeCompare.c (43 KB).</p>
               </td><td width="60">
<p><a href="http://developer.apple.com/library/mac/technotes/tn/downloads/tn1150.1.hqx">Download</a></p>
               </td></tr>
         </tbody></table></center>
         
         

</td></tr></tbody></table></center>
<div id="globalfooter" class="hideInXcode hideOnPrint">
<div class="gf-sosumi">
    <p>Copyright © 2010 Apple Inc. All rights reserved.</p>
    <ul class="piped">
    <li><a href="http://www.apple.com/legal/terms/site.html" class="first" target="_top">Terms of Use</a></li>
    <li><a href="http://www.apple.com/legal/privacy/" target="_top">Privacy Policy</a></li>
    </ul>
</div>
    </div><!--/globalfooter--><!-- end_footer_information -->


</div>
<!-- /CONTENTS --></article>

<!-- INSERT BREADCRUMB -->


<script type="text/javascript" src="pagetracker.js"></script>
<script type="text/javascript">
if(typeof PageTracker !== 'undefined') {
  if(window.addEventListener) {
    window.addEventListener("load", function(){PageTracker.logPageLoad()},false);
  } else if(window.attachEvent) {
    window.attachEvent("onload",function(){PageTracker.logPageLoad()});
  }
}
</script>

<div class="vimiumHUD" style="right: 150px; zoom: 100%; opacity: 0; display: none; ">/N<span style="font-size: 0px;"> </span>o<span style="font-size: 0px;"> </span>d<span style="font-size: 0px;"> </span>e<span style="font-size: 0px;"> </span>D<span style="font-size: 0px;"> </span>e<span style="font-size: 0px;"> </span>s<span style="font-size: 0px;"> </span>=<span style="font-size: 0px;"> </span>=<span style="font-size: 0px;"> </span>=<span style="font-size: 0px;"> </span>= (<span style="font-size: 0px;"> </span>N<span style="font-size: 0px;"> </span>o M<span style="font-size: 0px;"> </span>a<span style="font-size: 0px;"> </span>t<span style="font-size: 0px;"> </span>c<span style="font-size: 0px;"> </span>h<span style="font-size: 0px;"> </span>e<span style="font-size: 0px;"> </span>s<span style="font-size: 0px;"> </span>)<span style="font-size: 0px;"> </span></div></body></html>
